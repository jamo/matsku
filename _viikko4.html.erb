<section class="viikkoraja" id="4"><div class="viikkoraja">Viikko 4</div>
<div class="viikkoraja-mooc" id="Viikko 4" deadline="17.3.2013 23.59" data-first-chapter-index="20" data-first-exercise-index="72" data-first-week-index="4" data-first-chapter-index-mooc="20" data-first-exercise-index-mooc="72" data-first-week-index-mooc="4" tekija="Arto Vihavainen, Matti Luukkainen">


  <h2 id="olio_ohjelmointi">Olio-ohjelmointi</h2>
  <p>Pieni johdanto olio-ohjelmointiin ennen aloitusta.</p>
  <p>Proseduraalisessa ohjelmoinnissa, eli tähän asti opiskelemassamme ohjelmointityylissä, ohjelma jäsennellään jakamalla se pienempiin osiin eli metodeihin.  Metodi toimii ohjelman erillisenä osana, ja sitä voi kutsua mistä tahansa ohjelmasta.  Metodia kutsuttaessa ohjelman suoritus siirtyy metodin alkuun, ja suorituksen päätyttyä palataan takaisin siihen kohtaan mistä metodia kutsuttiin.</p>
  <p>Olio-ohjelmoinnissa, kuten proseduraalisessa ohjelmoinnissa, pyritään jakamaan ohjelma pieniin osiin.  Olio-ohjelmoinnissa pienet osat ovat olioita.  Jokaisella oliolla on oma yksittäinen vastuunsa eli se sisältää joukon yhteenkuuluvaa tietoa ja toiminnallisuutta.  Olio-ohjelmat koostuvat useista olioista, joiden yhteinen toiminta määrittelee järjestelmän toiminnan.</p>
  <h3>Olio</h3>
  <p>Olemme käyttäneet jo monia Javan valmiita olioita. Esimerkiksi <code>ArrayList</code>:it ovat olioita. Jokainen yksittäinen lista koostuu yhteenkuuluvasta tiedosta, eli <i>olion tilasta</i>. Listaolioihin liittyy toiminnallisuutta, eli metodt joilla olion tilaa voidaan muuttaa. Esimerkiksi seuraavassa ohjelmanpätkässä on kaksi <code>ArrayList</code>-olioa <code>kaupungit</code> ja <code>maat</code>:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; kaupungit = new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; maat = new ArrayList&lt;String&gt;();

    maat.add("Suomi");
    maat.add("Saksa");
    maat.add("Hollanti");

    kaupungit.add("Berliini");
    kaupungit.add("Nijmegen");
    kaupungit.add("Turku");
    kaupungit.add("Helsinki");

    System.out.println("maita " + maat.size() );
    System.out.println("kaupunkeja " + kaupungit.size() );
}
</pre>
  <p>Sekä <code>maat</code>-olio että <code>kaupungit</code>-olio elää omaa elämäänsä. Molempien "tila" on toisten olioiden tilasta riippumaton. Esim. olion <code>maat</code> tila koostuu listalla olevista merkkijonoista "Suomi", "Saksa" ja "Hollanti" ja todennäköisesti myös tiedosta kuinka monta maata listalla on.</p>
  <p>Olioon liittyvää metodikutsua tehdessä (esimerkiksi <code>maat.add("Suomi");</code>) pisteen vasemmalle puolelle tulee sen olion nimi, jolle metodia kutsutaan, oikealle metodin nimi. Kun kysytään monta merkkijonoa listalla <code>maat</code> on, kutsu on muotoa <code>maat.size()</code> eli kutsutaan <code>maat</code> oliolle sen metodia <code>size</code>. Metodin palauttama tulos riippuu olion <code>maat</code> tilasta, eli muut oliot kuten <code>kaupungit</code> eivät vaikuta metodin suoritukseen millään tavalla.</p>
  <p>Olemme jo useasti käyttämään komentoa <code>new</code>. Esimerkiksi listan (<code>ArrayList</code>) ja lukijan (<code>Scanner</code>) luominen on tapahtunut <code>new</code>-komennolla. Syy on se, että kumpikin näistä on <em>Luokkia</em>, joista olio luodaan. Java-kielessä oliot luodaan aina <code>new</code>-komennolla muutamaa poikkeusta lukuunottamatta.</p>
  <p>Yksi näistä poikkeuksista ovat merkkijonot, joiden luomiseen ei aina tarvita <code>new</code>:iä. Tuttu tapa merkkijonon luomiseen on oikeastaan Javan lyhennysmerkintä <code>new</code>:in käytölle. Merkkijonon voi luoda myös new:illä kuten muutkin oliot:</p>
<pre class="sh_java">
String teksti = "tekstiä";       // lyhennysmerkintä merkkijono-olion luomiselle
String toinenTeksti = new String("lisää tekstiä");   
</pre>
  
  <p>On myös tilanteita, missä Javan valmis kalusto kutsuu <code>new</code>:iä piilossa ohjelmoijalta.</p>
  <h3>Luokka</h3>
  <p>On selvää että kaikki oliot eivät ole keskenään samankaltaisia. Esim. <code>ArrayList</code>-oliot poikkeavat ratkaisevasti <code>String</code>-olioista. Kaikilla <code>ArrayList</code>:eillä on samat metodit (<code>add</code>, <code>contains</code>, <code>remove</code>, <code>size</code>, ...) ja vastaavasi kaikilla <code>String</code>-olioilla on samat metodit (<code>substring</code>, <code>length</code>, <code>charAt</code>, ...). <code>ArrayList</code>- ja <code>String</code>-olioiden metodit eivät ole samat sillä ne ovat eri <em>tyyppisiä</em> olioita.</p>
  <p>Tietyn olioryhmän tyyppiä kutsutaan <b>luokaksi</b>. <code>ArrayList</code> on luokka, <code>String</code> on luokka, <code>Scanner</code> on luokka, jne... Oliot taas ovat luokasta tehtyjä <em>ilmentymiä</em>.</p>
  <p>Luokan kaikilla olioilla on samat metodit, sekä samankaltainen tila. Esim. kaikkien <code>ArrayList</code>-olioiden tila koostuu listalle tallennetuista alkioista. <code>String</code>-olioiden tila taas koostuu merkkijonon muodostavista kirjaimista.</p>
  <h3>Luokka ja sen oliot</h3>
  <p><b>Luokka määrittelee</b> minkälaisia luokan oliot ovat:</p>
  <ul>
<li><b>mitä metodeita olioilla on</b></li>
    <li>
<b>minkälainen olioiden tila on</b> tai toisinsanoen mitä ominaisuuksia olioilla on</li>
  </ul>
<p>Luokka kuvaa siitä luotavien olioiden "rakennuspiirustukset".</p>
  <p>Otetaan analogia tietokoneiden ulkopuoleisesta maailmasta. Rintamamiestalot lienevät kaikille suomalaisille tuttuja. Voidaan ajatella, että jossain on olemassa piirustukset jotka määrittelevät minkälainen rintamamiestalo on. Piirrustukset ovat luokka, eli ne määrittelevät luokasta luotavien olioiden luonteen:</p>
  <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/luokka.jpg"></p>
  <p>Yksittäiset oliot eli rintamamiestalot on tehty samojen piirustusten perusteella, eli ne ovat saman luokan ilmentymiä. Yksittäisten olioiden tila eli ominaisuudet (esim. seinien väri, katon rakennusmateriaali ja väri, kivijalan väri, ovien rakennusmateriaali ja väri, ...) vaihtelevat. Seuraavassa yksi "rintamamiestalo-luokan olio":</p>
  <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/olio.jpg" height="250"></p>
  <p>Luokasta luodaan olio aina kutsumalla olion luovaa metodia eli <em>konstruktoria</em> komennon <code>new</code> avulla. Esimerkiksi <code>Scanner</code>-luokasta luodaan uusi ilmentymä eli olio kun kutsutaan <code>new Scanner(..)</code>:</p>
  <pre class="sh_java">
  Scanner lukija = new Scanner(System.in);
</pre>
  <p>Konstruktorit saavat parametreja kuten muutkin metodit.</p>
  <div class="tehtavat" id="viikko4">
    <div class="tehtava">
    <h3>Tilejä</h3>
    <p>Tehtäväpohjan mukana tulee valmis luokka <code>Tili</code>.
      Luokan <code>Tili</code> olio esittää pankkitiliä, jolla on saldo
      (eli jossa on jokin määrä rahaa). Tilejä käytetään näin:</p>
    <pre class="sh_java">
Tili artonTili = new Tili("Arton tili",100.00);
Tili artonSveitsilainenTili = new Tili("Arton tili Sveitsissä",1000000.00);

System.out.println("Alkutilanne");
System.out.println(artonTili);
System.out.println(artonSveitsilainenTili);

artonTili.otto(20);
System.out.println("Arton tilin saldo on nyt: "+artonTili.saldo());
artonSveitsilainenTili.pano(200);
System.out.println("Arton toisen tilin saldo on nyt: "+artonSveitsilainenTili.saldo());

System.out.println("Lopputilanne");
System.out.println(artonTili);
System.out.println(artonSveitsilainenTili);
</pre>
    <h4>Ensimmäinen tilisi</h4>
    <p>
      <large><b>Huom:</b> tämän tehtävän jokaista alikohtaa varten on oma tehtäväpohja, tee tämä tehtävä pohjaan 072.1</large></p>
    <p>Tee ohjelma, joka luo tilin jonka saldo on 100.0, panee tilille
      20.0 ja tulostaa tilin. <strong>Huom!</strong> tee kaikki nämä
      operaatiot täsmälleen tässä järjestyksessä.</p>
    <h4>Ensimmäinen tilisiirtosi</h4>
    <p>
      <large><b>Huom:</b> tämän tehtävän jokaista alikohtaa varten on oma tehtäväpohja, tee tämä tehtävä pohjaan 072.2</large></p>
    <p>Tee ohjelma joka:</p>
    <ol class="lista">
<li>Luo tilin nimeltä <code>"Matin tili"</code> saldolla 1000</li>
      <li>Luo tilin nimeltä <code>"Oma tili"</code> saldolla 0</li>
      <li>Nostaa matin tililtä 100.0</li>
      <li>Panee omalle tilille 100.0</li>
      <li>Tulosta molemmat tilit</li>
    </ol>
<h4>Tilisiirtoja</h4>
    <p>
      <large><b>Huom:</b> tämän tehtävän jokaista alikohtaa varten on oma tehtäväpohja, tee tämä tehtävä pohjaan 072.3</large></p>
    <p>Yllä siirsit rahaa tililtä toiselle. Tehdään seuraavaksi metodi joka tekee saman!</p>
    <p>Toteuta ohjelmapohjaan metodi <code>public static void tilisiirto(Tili
      mista, Tili minne, double paljonko)</code> joka siirtää rahaa
      tililtä toiselle. Sinun ei tarvitse tarkistaa
      että <code>mista</code>-tilin saldo riittää.</p>
    <p>Tämän jälkeen tee <code>main</code>-metodissasi seuraavaa:</p>
    <ol class="lista">
<li>Luo tili <code>"A"</code> saldolla 100.0</li>
      <li>Luo tili <code>"B"</code> saldolla 0.0</li>
      <li>Luo tili <code>"C"</code> saldolla 0.0</li>
      <li>Siirrä 50.0 tililtä A tilille B.</li>
      <li>Siirrä 25.0 tililtä B tilille C.</li>
    </ol>
</div>
</div>
  <h3>Oman luokan määritteleminen - oliomuuttujat</h3>
  <p>Luokka määritellään jotain mielekästä kokonaisuutta varten. Usein "mielekäs kokonaisuus" kuvaa jotain reaalimaailman asiaa. Jos tietokoneohjelman pitää käsitellä henkilötietoja, voisi olla mielekästä määritellä erillinen luokka <code>Henkilo</code> joka kokoaa yhteen henkilöön liittyvät metodit ja ominaisuudet.</p>
  <p>Aloitetaan. Oletetaan että meillä on projektirunko jossa on tyhjä pääohjelma:</p>
  <pre class="sh_java">
public class Main {

    public static void main(String[] args) {

    }

}
  </pre>
  <p>Luomme nyt projektiimme eli ohjelmaamme uuden luokan. Tämä tapahtuu valitsemalla NetBeansissa vasemmalta <em>projects</em>-kohdasta hiiren oikealla napilla <em>new</em> ja <em>java class</em>. Avautuvaan dialogiin annetaan luokalle nimi.</p>
  <p>Kuten muuttujien ja metodien nimien, myös luokan nimen on aina oltava mahdollisimman kuvaava. Joskus ohjelmoinnin edetessä luokka elää ja muuttaa muotoaan. Tällaisissa tilanteissa luokan voi nimetä uudelleen (

        <!-- BEGIN mini MOOC SNIP-->
    <a class="ahy" href="netbeans.html">ks. NetBeans ohje</a>
    <!-- END mini MOOC SNIP-->
    <!-- BEGIN mini SNIP-->
    <a class="amooc" href="http://mooc.cs.helsinki.fi/ohjelmointi/ohjeita#netbeans">ks. NetBeans ohje</a>
    <!-- END mini SNIP-->).</p>
  <p>Luodaan luokka nimeltä <code>Henkilo</code>. Luokasta muodostuu oma tiedostonsa <code>Henkilo.java</code>. Eli ohjelma koostuu nyt kahdesta tiedostosta, sillä pääohjelma on omassa tiedostossaan. Aluksi luokka on tyhjä:</p>
  <pre class="sh_java">
public class Henkilo {

}
</pre>
  <p>Luokan tulee määritellä mitä metodeja ja ominaisuuksia luokan olioilla on. Päätetään, että jokaisella henkilöllä on nimi ja ikä. Nimi on luonnollista esittää merkkijonona, eli Stringinä, ja ikä taas kokonaislukuna. Lisätään nämä rakennuspiirustuksiimme:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;
}
</pre>
  <p>Määrittelimme yllä että kaikilla <code>Henkilo</code>-luokan olioilla on <code>nimi</code> ja <code>ika</code>. Määritettely tapahtuu hiukan kuten normaalin muuttujan määrittely. Eteen on kuitenkin nyt laitettu avainsana <code>private</code>. Tämä tarkoittaa sitä, että nimi ja ikä eivät näy suoraan olion ulkopuolelle vaan ovat "piilossa" olion sisällä. Olion sisälle piilottamista kutsutaan <em>kapseloinniksi</em>.</p>
  <p>Luokan sisälle määriteltyjä muuttujia kutsutaan <i>oliomuuttujiksi</i> tai <i>olion kentiksi</i> tai <i>olion attribuuteiksi</i>. Rakkaalla lapsella on monta nimeä.</p>
  <p>Eli olemme määritelleet rakennuspiirrustukset -- luokan -- henkilöoliolle. Kaikilla henkilöolioilla on muuttujat <code>nimi</code> ja <code>ika</code>. Henkilöiden "tila" koostuu niiden nimeen ja ikään asetetuista arvoista.</p>
  <h3>Oman luokan määritteleminen - konstruktori eli tilan alustus</h3>
  <p>Luotavalle oliolle halutaan asettaa luontivaiheessa jokin alkutila. Itse määritellyn olion luominen tapahtuu hyvin samaan tapaan kuin Javan valmiiden olioiden kuten <code>ArrayList</code>:ien luominen. Oliot siis luodaan <code>new</code>-komennolla. Olion synnyttämisen yhteydessä olisikin kätevä pystyä antamaan arvo joillekin olioiden muuttujille. Esim. henkilön synnytyksessä olisi kätevää pystyä antamaan nimi jo syntymähetkellä: </p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka");
    // ...
}
</pre>
  <p>Tämä onnistuu määrittelemällä olion synnyttävä metodi, eli <em>konstruktori</em>. Seuraavassa on määritelty <code>Henkilo</code>-luokalle konstruktori, joka luo uuden <code>Henkilo</code>-olion. Konstruktorissa luotavan henkilön iäksi asetetaan 0 ja nimeksi parametrina tuleva merkkijono:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimiAlussa) {
        this.ika = 0;
        this.nimi = nimiAlussa;
      }
}
</pre>
  <p>Konstruktori on siis nimeltään sama kuin luokan nimi. Yllä luokka (<em>class</em>) on <code>Henkilo</code>, ja konstruktori <code>public Henkilo(String nimiAlussa)</code>. Konstruktorille parametrina tuleva arvo tulee sulkuihin konstruktorin nimen perään. Konstruktorin voi ajatella olevan metodi, jonka Java suorittaa kun olio luodaan sanomalla <code>new Henkilo("Pekka");</code> Aina kun jostain luokasta luodaan olio, kutsutaan kyseisen luokan konstruktoria. </p>
  <p>Muutama huomio: konstruktorin sisällä on komento <code>this.ika = 0</code>. Tässä asetetaan arvo 0 <em>juuri tämän olion, eli "this"-olion</em> sisäiselle muuttujalle <code>ika</code>. Toinen komento <code>this.nimi = nimiAlussa;</code> taas asettaa juuri tämän olion sisäiselle muuttujalle <code>nimi</code> arvoksi parametrina annetun merkkijonon. Olion muuttujat <code>ika</code> ja <code>nimi</code> näkyvät konstruktorissa ja muuallakin olion sisällä automaattisesti. Niihin viitataan <code>this</code>-etuliitteellä. Koska niissä on private-määre, niin olion ulkopuolelle ne eivät näy.</p>
  <p>Vielä yksi huomio: jos ohjelmoija ei tee luokalle konstruktoria, tekee Java automaattisesti luokalle oletuskonstruktorin. Oletuskonstruktori on konstruktori joka ei tee mitään. Eli jos konstruktoria ei jostain syystä tarvita, ei sellaista tarvitse ohjelmoida.</p>
  <h3>Oman luokan määritteleminen - metodit</h3>
  <p>Alkaa olla korkea aika päästä käyttämään <code>Henkilo</code>-olioita. Osaamme luoda olion ja alustaa olion muuttujat. Järkevään toimintaan pystyäkseen olioilla on oltava myös metodeja. Tehdään <code>Henkilo</code>-luokalle metodi jonka avulla olio tulostaa itsensä ruudulle:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimiAlussa) {
        this.ika = 0;
        this.nimi = nimiAlussa;
    }

    public void tulostaHenkilo() {
        System.out.println(this.nimi + ", ikä " + this.ika + " vuotta");
    }
}
</pre>
  <p>Metodi siis kirjoitetaan luokan sisälle, metodin nimen eteen tulee <code>public void</code> sillä metodin on tarkoitus näkyä ulkomaailmalle ja metodi ei palauta mitään. Huomaa, että sana <code>static</code> ei nyt ilmene missään. Olioiden yhteydessä <code>static</code>-määrettä ei käytetä. Selitämme ensi viikolla hieman tarkemmin mistä tässä on kysymys.</p>
  <p>Metodin <code>tulostaHenkilo</code> sisällä on yksi koodirivi joka käyttää hyvakseen oliomuuttujia <code>nimi</code> ja <code>ika</code>. Juuri tämän olion muuttujiin viitataan taas etuliitteellä <code>this</code>. Kaikki olion muuttujat ovat siis näkyvillä ja käytettävissä metodin sisällä.</p>
  <p>Luodaan pääohjelmassa kolme henkilöä ja pyydetään niitä tulostamaan itsensä:</p>
  <pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka");
        Henkilo antti = new Henkilo("Antti");
        Henkilo martin = new Henkilo("Martin");

        pekka.tulostaHenkilo();
        antti.tulostaHenkilo();
        martin.tulostaHenkilo();
    }
}
</pre>
  <p>Tulostuu:</p>
<pre>
Pekka, ikä 0 vuotta
Antti, ikä 0 vuotta
Martin, ikä 0 vuotta
</pre>
  <p>Sama screencastina: </p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=fWwXQ5n2gYo" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> 


  <div class="tehtavat">
    <div class="tehtava">
    <h3>Tuote</h3>
    <p>Luo luokka <code>Tuote</code> joka esittää kaupan tuotetta jolla on hinta, lukumäärä ja nimi.</p>
    <p> Uuden luokan saa lisättyä seuraavasti: Ruudun vasemmalla reunalla on projektilistaus. Paina projektin nimen <em>073.Tuote</em> kohdalla hiiren oikeaa nappia. Valitse avautuvasta valikosta <em>New</em> ja <em>Java Class</em>. Anna luokan nimeksi (Class Name) <code>Tuote</code>. </p>
    <p>Luokalla tulee olla:</p>
    <ul>
<li>Konstruktori <code>public Tuote(String nimiAlussa, double hintaAlussa, int maaraAlussa)</code>
</li>
      <li>Metodi <code>public void tulostaTuote()</code> joka tulostaa tuotteen tiedot tässä muodossa:
        <pre>
Banaani, hinta 1.1, 13 kpl
      </pre>
      </li>
    </ul>
</div>
</div>
  <h3>lisää metodeja</h3>
  <p>Lisätään aiemmin rakentamallemme Henkilölle metodi, joka kasvattaa henkilön ikää vuodella:</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public void vanhene() {
      this.ika = this.ika + 1;
    }
}
</pre>
  <p>Metodi siis kirjoitetaan <code>tulostaHenkilo</code>-metodin tapaan luokan <code>Henkilo</code> sisälle. Metodissa kasvatetaan oliomuuttujan <code>ika</code> arvoa yhdellä.</p>
  <p>Kutsutaan metodia ja katsotaan mitä tapahtuu:</p>
  <pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka");
        Henkilo antti = new Henkilo("Antti");

        pekka.tulostaHenkilo();
        antti.tulostaHenkilo();

        System.out.println("");

        pekka.vanhene();
        pekka.vanhene();

        pekka.tulostaHenkilo();
        antti.tulostaHenkilo();
      }
}
</pre>
  <p>Ohjelman tulostus on seuraava:</p>
  <pre>
Pekka, ikä 0 vuotta
Antti, ikä 0 vuotta

Pekka, ikä 2 vuotta
Antti, ikä 0 vuotta
</pre>
  <p>Eli "syntyessään" molemmat oliot ovat nollavuotiaita (konstruktorissa suoritetaan mm. rivi <code>this.ika = 0;</code>). Olion <code>pekka</code> metodia <code>vanhene</code> kutsutaan kaksi kertaa. Kuten tulostus näyttää, tämä saa aikaan sen että Pekan ikä vanhenemisen jälkeen 2 vuotta. Kutsumalla metodia Pekkaa vastaavalle oliolle, toisen henkilöolion ikä ei muutu.</p>
  <p>Jokaisella oliolla on siis oma sisäinen tilansa.</p>
  <p>Aivan kuiten edellisellä viikolla käsittelemämme olioihin liittymättömät metodit, myös olioihin liittyvät metodit voivat palauttaa arvon. Lisätään Henkilölle metodi joka palauttaa henkilön iän:</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public int palautaIka() {
        return this.ika;
    }
}
</pre>
  <p>Eli koska kyseessä olioon liittyvä metodi, ei määrittelyssä ole sanaa static. Olioiden arvon palauttavia metodeja käytetään kuten mitä tahansa arvon palauttavia metodeja:</p>
  <pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka");
        Henkilo antti = new Henkilo("Antti");

        pekka.vanhene();
        pekka.vanhene();

        antti.vanhene();

        System.out.println( "Pekan ikä: "+pekka.palautaIka() );
        System.out.println( "Antin ikä: "+antti.palautaIka() );

        int yht = pekka.palautaIka() + antti.palautaIka();

        System.out.println( "Pekka ja Antti yhteensä "+yht+ " vuotta" );
    }
}
</pre>
  <p>Ohjelman tulostus on seuraava:</p>
  <pre>
Pekan ikä 2
Antin ikä 1

Pekka ja Antti yhteensä 3 vuotta
</pre>
<div class="tehtavat">
  <div class="tehtava">
    <h3>Kertoja</h3>
    <p>Luo luokka <code>Kertoja</code> jolla on:</p>
    <ul>
<li>Konstruktori <code>public Kertoja(int luku)</code>.</li>
      <li>Metodi <code>public int kerro(int toinenLuku)</code> joka palauttaa sille annetun luvun <code>toinenLuku</code> kerrottuna konstruktorille annetulla luvulla <code>luku</code>.</li>
    </ul>
<p>Esimerkki luokan käytöstä:</p>
    <pre class="sh_java">
Kertoja kolmellaKertoja = new Kertoja(3);

System.out.println("kolmellaKertoja.kerro(2): " + kolmellaKertoja.kerro(2));

Kertoja neljallaKertoja = new Kertoja(4);

System.out.println("neljallaKertoja.kerro(2): " + neljallaKertoja.kerro(2));
System.out.println("kolmellaKertoja.kerro(1): " + kolmellaKertoja.kerro(1));
System.out.println("neljallaKertoja.kerro(1): " + neljallaKertoja.kerro(1));
  </pre>
    <p>Tulostus</p>
<pre>
kolmellaKertoja.kerro(2): 6
neljallaKertoja.kerro(2): 8
kolmellaKertoja.kerro(1): 3
neljallaKertoja.kerro(1): 4
</pre>
</div>
<div class="tehtava">
    <h3>Vähenevä laskuri</h3>
    <p>Tehtäväpohjan mukana tulee osittain valmiiksi toteutettu luokka <code>VahenevaLaskuri</code>:</p>
    <pre class="sh_java">
public class VahenevaLaskuri {
    private int arvo;   // oliomuuttuja joka muistaa laskurin arvon

    public VahenevaLaskuri(int arvoAlussa) {
        this.arvo = arvoAlussa;
    }

    public void tulostaArvo() {
        System.out.println("arvo: " + this.arvo);
    }

    public void vahene() {
        // kirjoita tänne metodin toteutus
        // laskurin arvon on siis tarkoitus vähentyä yhdellä
    }

    // ja tänne muut metodit
}
</pre>
    <p>Seuraavassa esimerkki miten pääohjelma käyttää vähenevää laskuria: </p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        VahenevaLaskuri laskuri = new VahenevaLaskuri(10);

        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();
    }
}
</pre>
    <p>Pitäisi tulostua:</p>
<pre>
arvo: 10
arvo: 9
arvo: 8
</pre>
    <p><code>VahenevaLaskuri</code>-luokan konstruktorille annetaan parametrina alkuarvo. Esimerkin oliota <code>laskuri</code> luodessa laskurille välitetään parametrina arvo <code>10</code>. Esimerkin <code>laskuri</code>-olioon liittyvään oliomuuttujaan <code>arvo</code> asetetaan siis aluksi arvo <code>10</code>. Laskurin arvon voi tulostaa metodilla <code>tulostaArvo()</code>. Laskurilla tulee myös olla metodi <code>vahene()</code> joka vähentää laskurin arvoa yhdellä.</p>
    <h4>Metodin vahene() toteutus</h4>
    <p>Täydennä luokan runkoon metodin <code>vahene()</code> toteutus sellaiseksi, että se vähentää kutsuttavan olion oliomuuttujan <code>arvo</code> arvoa yhdellä. Kun olet toteuttanut metodin <code>vahene()</code>, edellisen esimerkin pääohjelman tulee toimia esimerkkitulosteen mukaan.</p>
    <h4>Laskurin arvo ei saa olla negatiivinen</h4>
    <p>Täydennä metodin <code>vahene()</code> toteutus sellaiseksi, ettei laskurin arvo mene koskaan negatiiviseksi. Eli jos laskurin arvo on jo 0, ei vähennys sitä enää vähennä:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        VahenevaLaskuri laskuri = new VahenevaLaskuri(2);

        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();
    }
}
</pre>
    <p>Tulostuu:</p>
<pre>
arvo: 2
arvo: 1
arvo: 0
arvo: 0
</pre>
    <h4>Laskurin arvon nollaus</h4>
    <p>Tee laskurille metodi <code>public void nollaa()</code> joka nollaa laskurin arvon, esim:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        VahenevaLaskuri laskuri = new VahenevaLaskuri(100);

        laskuri.tulostaArvo();

        laskuri.nollaa();
        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();
    }
}
</pre>
    <p>Tulostuu:</p>
<pre>
arvo: 100
arvo: 0
arvo: 0
</pre>
    <h4>Laskurin arvon palautus</h4>
    <p>Tee laskurille metodi <code>public void palautaAlkuarvo()</code>, joka palauttaa laskurille arvon joka sillä oli alussa:</p>
    <pre class="sh_java">
public class Paaohjelma {
  public static void main(String[] args) {
      VahenevaLaskuri laskuri = new VahenevaLaskuri(100);

      laskuri.tulostaArvo();

      laskuri.vahene();
      laskuri.tulostaArvo();

      laskuri.vahene();
      laskuri.tulostaArvo();

      laskuri.nollaa();
      laskuri.tulostaArvo();

      laskuri.palautaAlkuarvo();
      laskuri.tulostaArvo();
    }
}
</pre>
<p>Tulostuu:</p>
<pre>
arvo: 100
arvo: 99
arvo: 98
arvo: 0
arvo: 100
</pre>
    <p><strong>Vihje</strong> jotta alkuarvon voi palauttaa, se täytyy "muistaa" toisen oliomuuttujan avulla! Joudut siis lisäämään ohjelmaan oliomuuttujan johon talletetaan laskurin alussa saama arvo.</p>
  </div>
  <div class="tehtava">
    <h3>Ruokalista</h3>
    <p>Kumpulan kampuksella Helsingissä toimivaan Unicafe-nimiseen gourmet-ravintolaan tarvitaan uusi ruokalista. Keittiömestari tietää ohjelmoinnista, ja haluaa listan hallinnointiin tietokonejärjestelmän. Toteutetaan tässä tehtävässä järjestelmän sydän, luokka Ruokalista.</p>
    <p>Tehtäväpohjan mukana tulee <code>Main</code>-luokka, jossa voit testata ruokalistan toimintaa. Ruokalistan toteuttamista varten saat seuraavanlaisen tehtäväpohjan:</p>
    <pre class="sh_java">
import java.util.ArrayList;

public class Ruokalista {

    private ArrayList&lt;String&gt; ateriat;

    public Ruokalista() {
        this.ateriat = new ArrayList&lt;String&gt;();
    }

    // toteuta tänne tarvittavat metodit
}
</pre>
    <p>Ruokalistaoliolla on siis oliomuuttujana ArrayList, jonka on tarkoitus tallentaa ruokalistalla olevien ruokalajien nimet.</p>
    <p>Ruokalistan tulee tarjota metodit <code>public void lisaaAteria(String ateria)</code>, <code>public void tulostaAteriat()</code>, ja <code>public void tyhjennaRuokalista()</code>.</p>
    <h4>Aterian lisääminen</h4>
    <p>Toteuta metodi <code>public void lisaaAteria(String ateria)</code>, joka lisää uuden aterian ruokalistan <code>ateriat</code>-listaan. Jos lisättävä ateria on jo listassa, sitä ei lisätä uudelleen.</p>
    <h4>Aterioiden tulostaminen</h4>
    <p>Toteuta metodi <code>public void tulostaAteriat()</code>, joka tulostaa ateriat. Esimerkiksi kolmen aterian lisäyksen jälkeen tulostuksen tulee olla seuraavanlainen.</p>
<pre>
ensimmäisenä lisätty ateria
toisena lisätty ateria
kolmantena lisätty ateria
</pre>
    <h4>Ruokalistan tyhjentäminen</h4>
    <p>Toteuta metodi <code>public void tyhjennaRuokalista()</code> joka tyhjentää ruokalistan. <code>ArrayList</code>-luokalla on metodi josta on tässä hyötyä. NetBeans osaa vihjata käytettävissä olevista metodeista kun kirjoitat olion nimen ja pisteen. Yritä kirjoittaa <code>ateriat.</code> metodirungon sisällä ja katso mitä käy.</p>
  </div>
</div>
  <h3>Henkilo-luokka laajenee</h3>
  <p>Jatketaan taas <code>Henkilo</code>-luokan laajentamista. Luokan tämänhetkinen versio on seuraava:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimiAlussa) {
        this.ika = 0;
        this.nimi = nimiAlussa;
    }

    public void tulostaHenkilo() {
        System.out.println(this.nimi + ", ikä " + this.ika + " vuotta");
    }

    public void vanhene() {
        this.ika = this.ika + 1;
    }
}
</pre>
  <p>Tehdään henkilölle metodi, jonka avulla voidaan selvittää onko henkilö täysi-ikäinen. Metodi palauttaa totuusarvon -- joko <code>true</code> tai <code>false</code>:</p>
  <pre class="sh_java">
public class Henkilo {
  // ...

  public boolean taysiIkainen(){
      if ( this.ika &lt; 18 ) {
          return false;
      }

      return true;
    }

    /*
    huom. metodin voisi kirjoittaa lyhyemmin seuraavasti:

    public boolean taysiIkainen(){
        return this.ika &gt;= 18;
    }
    */
}
</pre>
  <p>Ja testataan:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo antti = new Henkilo("Antti");

    int i = 0;
    while ( i &lt; 30 ) {
        pekka.vanhene();
        i++;
    }

    antti.vanhene();

    System.out.println("");

    if ( antti.taysiIkainen() ) {
        System.out.print("täysi-ikäinen: ");
        antti.tulostaHenkilo();
    } else {
        System.out.print("alaikäinen: ");
        antti.tulostaHenkilo();
    }

    if ( pekka.taysiIkainen() ) {
        System.out.print("täysi-ikäinen: ");
        pekka.tulostaHenkilo();
    } else {
        System.out.print("alaikäinen: ");
        pekka.tulostaHenkilo();
    }
}
</pre>
  <pre>
alaikäinen: Antti, ikä 1 vuotta
täysi-ikäinen: Pekka, ikä 30 vuotta
</pre>
  <p>Viritellään ratkaisua vielä hiukan. Nyt henkilön pystyy "tulostamaan" ainoastaan siten, että nimen lisäksi tulostuu ikä. On tilanteita, joissa haluamme tietoon pelkän olion nimen. Eli tehdään tarkoitusta varten oma metodi:</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public String getNimi() {
        return this.nimi;
      }
}
</pre>
  <p>Metodi <code>getNimi</code> palauttaa oliomuuttujan <code>nimi</code> kutsujalle. Metodin nimi on hieman erikoinen. Javassa on usein tapana nimetä oliomuuttujan palauttava metodi juuri näin, eli <code>getMuuttujanNimi</code>. Tälläisiä metodeja kutsutaan usein "gettereiksi".</p>
  <p>Muotoillaan pääohjelma käyttämään uutta "getteri"-metodia:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo antti = new Henkilo("Antti");

    int i = 0;
    while ( i &lt; 30 ) {
        pekka.vanhene();
        i++;
    }

    antti.vanhene();

    System.out.println("");

    if ( antti.taysiIkainen() ) {
        System.out.println( antti.getNimi() + " on täysi-ikäinen" );
    } else {
        System.out.println( antti.getNimi() + " on alaikäinen" );
    }

    if ( pekka.taysiIkainen() ) {
        System.out.println( pekka.getNimi() + " on täysi-ikäinen" );
    } else {
        System.out.println( pekka.getNimi() + " on alaikäinen " );
    }
}
</pre>
  <p>Tulostus alkaa olla jo aika siisti:</p>
  <pre>
Antti on alaikäinen
Pekka on täysi-ikäinen
</pre>

  <h3>toString</h3>
  <p>Olemme syyllistyneet edellä osittain huonoon ohjelmointityyliin tekemällä metodin jonka avulla olio tulostetaan, eli metodin <code>tulostaHenkilo</code>. Suositeltavampi tapa on määritellä oliolle metodi jonka palauttaa olion "merkkijonoesityksen". Merkkijonoesityksen palauttavan metodin nimi on Javassa aina <code>toString</code>. Määritellään seuraavassa henkilölle tämä metodi:</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public String toString() {
        return this.nimi + ", ikä " + this.ika + " vuotta";
    }
}
</pre>
  <p>Metodi <code>toString</code> toimii kuten <code>tulostaHenkilo</code>, mutta se ei itse tulosta mitään vaan palauttaa merkkijonoesityksen, jotta metodin kutsuja voi halutessaan suorittaa tulostamisen.</p>
  <p>Metodia käytetään hieman yllättävällä tavalla:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo antti = new Henkilo("Antti");

    int i = 0;
    while ( i &lt; 30 ) {
        pekka.vanhene();
        i++;
    }

    antti.vanhene();

    System.out.println( antti ); // sama kun System.out.println( antti.toString() );
    System.out.println( pekka ); // sama kun System.out.println( pekka.toString() );
}
</pre>
  <p>Periaatteena on, että <code>System.out.println</code>-metodi pyytää olion merkkijonoesityksen ja tulostaa sen. Merkkijonoesityksen palauttavan <code>toString</code>-metodin kutsua ei tarvitse kirjoittaa itse, sillä Java lisää sen automaattisesti. Ohjelmoijan kirjoittaessa:</p>
<pre class="sh_java">
System.out.println( antti );
</pre>
  <p>Java täydentää suorituksen aikana kutsun muotoon:</p>
<pre class="sh_java">
System.out.println( antti.toString() ); 
</pre>
  <p>Käy niin, että oliolta pyydetään sen merkkijonoesitys. Olion palauttama merkkijonoesitys tulostetaan normaaliin tapaan <code>System.out.println</code>-komennolla. </p>
  <p><b>Voimme nyt poistaa turhaksi käyneen <code>tulostaOlio</code>-metodin.</b></p>
  <p>Olioscreencastin toinen osa: </p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=d-56AxspStE" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> 
  
  <!--
<p><iframe allowfullscreen="" frameborder="0" height="450" width="700" src="http://www.youtube.com/embed/eX7XXP5GHTk"></iframe></p>
-->
  
  <div class="tehtavat">
    <div class="tehtava">
    <h3>Lyyra-kortti</h3>
    <p>Helsingin Yliopiston opiskelijaruokaloissa eli Unicafeissa opiskelijat maksavat lounaansa käyttäen <a href="http://www.lyyra.fi" target="_blank">Lyyra-korttia</a>.</p>
    <p>Tässä tehtäväsäsarjassa tehdään luokka <code>LyyraKortti</code>, jonka tarkoituksena on jäljitellä Lyyra-kortin käyttämistä Unicafessa.</p>
    <h4 class="req">Luokan runko</h4>
    <p>Projektiin tulee kuulumaan kaksi kooditiedostoa:</p>
    <p>Tehtäväpohjan eli projektin <em>Viikko4_077.Lyyrakortti</em> mukana tulee kooditiedosto <code>Paaohjelma</code> jonka sisällä on <code>main</code>-metodi.</p>
    <p>Lisää projektiin uusi luokka nimeltä <code>LyyraKortti</code>. Uuden luokan saa lisättyä seuraavasti: Ruudun vasemmalla reunalla on projektilistaus. Paina projektin nimen <em>Viikko4_077.Lyyrakortti</em> kohdalla hiiren oikeaa nappia. Valitse avautuvasta valikosta <em>New</em> ja <em>Java Class</em>. Anna luokan nimeksi (Class Name) <code>LyyraKortti</code>. </p>
    <p>Tee ensin <code>LyyraKortti</code>-olion konstruktori, jolle annetaan kortin alkusaldo ja joka tallentaa sen olion sisäiseen muuttujaan. Tee sitten <code>toString</code>-metodi, joka palauttaa kortin saldon muodossa "Kortilla on rahaa X euroa".</p>
    <p>Seuraavassa on luokan <code>LyyraKortti</code> runko:</p>
    <pre class="sh_java">
public class LyyraKortti {
    private double saldo;

    public LyyraKortti(double alkusaldo) {
        // kirjoita koodia tähän
    }

    public String toString() {
        // kirjoita koodia tähän
    }
}
</pre>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(50);
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
    <pre>
Kortilla on rahaa 50.0 euroa
</pre>
    <h4 class="req">Kortilla maksaminen</h4>
    <p>Täydennä <code>LyyraKortti</code>-luokkaa seuraavilla metodeilla:</p>
    <pre class="sh_java">
public void syoEdullisesti() {
    // kirjoita koodia tähän
}

public void syoMaukkaasti() {
      // kirjoita koodia tähän
}
</pre>
    <p>Metodin <code>syoEdullisesti</code> tulisi vähentää kortin saldoa 2.50 eurolla ja metodin <code>syoMaukkaasti</code> tulisi vähentää kortin saldoa 4.00 eurolla.</p>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(50);
        System.out.println(kortti);

        kortti.syoEdullisesti();
        System.out.println(kortti);

        kortti.syoMaukkaasti();
        kortti.syoEdullisesti();
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
    <pre>
Kortilla on rahaa 50.0 euroa
Kortilla on rahaa 47.5 euroa
Kortilla on rahaa 41.0 euroa
</pre>
    <h4 class="req">Ei-negatiivinen saldo</h4>
    <p>Mitä tapahtuu, jos kortilta loppuu raha kesken? Ei ole järkevää, että saldo muuttuu negatiiviseksi. Muuta metodeita <code>syoEdullisesti</code> ja <code>syoMaukkaasti</code> niin, että ne eivät vähennä saldoa, jos saldo menisi negatiiviseksi.</p>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(5);
        System.out.println(kortti);

        kortti.syoMaukkaasti();
        System.out.println(kortti);

        kortti.syoMaukkaasti();
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
<pre>
Kortilla on rahaa 5.0 euroa
Kortilla on rahaa 1.0 euroa
Kortilla on rahaa 1.0 euroa
</pre>
    <p>Yllä toinen metodin <code>syoMaukkaasti</code> kutsu ei vaikuttanut saldoon, koska saldo olisi mennyt negatiiviseksi.</p>
    <h4 class="req">Kortin lataaminen</h4>
    <p>Lisää <code>LyyraKortti</code>-luokkaan seuraava metodi:</p>
    <pre class="sh_java">
public void lataaRahaa(double rahamaara) {
    // kirjoita koodia tähän
}
</pre>
    <p>Metodin tarkoituksena on kasvattaa kortin saldoa parametrina annetulla rahamäärällä. Kuitenkin kortin saldo saa olla korkeintaan 150 euroa, joten jos ladattava rahamäärä ylittäisi sen, saldoksi tulisi tulla silti tasan 150 euroa.</p>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(10);
        System.out.println(kortti);

        kortti.lataaRahaa(15);
        System.out.println(kortti);

        kortti.lataaRahaa(10);
        System.out.println(kortti);

        kortti.lataaRahaa(200);
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
<pre>
Kortilla on rahaa 10.0 euroa
Kortilla on rahaa 25.0 euroa
Kortilla on rahaa 35.0 euroa
Kortilla on rahaa 150.0 euroa
</pre>
    <h4 class="req">Kortin lataus negatiivisella arvolla</h4>
    <p>Muuta metodia <code>lataaRahaa</code> vielä siten, että jos yritetään ladata negatiivinen rahamäärä, ei kortilla oleva arvo muutu.</p>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(10);
        System.out.println(kortti);
        kortti.lataaRahaa(-15);
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
<pre>
Kortilla on rahaa 10.0 euroa
Kortilla on rahaa 10.0 euroa
</pre>
    <h4 class="req">Monta korttia</h4>
    <p>Tee pääohjelma, joka sisältää seuraavan tapahtumasarjan:</p>
    <ul>
<li> Luo Pekan lyyrakortti. Kortin alkusaldo on 20 euroa</li>
      <li> Luo Matin lyyrakortti. Kortin alkusaldo on 30 euroa</li>
      <li> Pekka syö maukkaasti</li>
      <li> Matti syö edullisesti</li>
      <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
      <li> Pekka lataa rahaa 20 euroa</li>
      <li> Matti syö maukkaasti</li>
      <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
      <li> Pekka syö edullisesti</li>
      <li> Pekka syö edullisesti</li>
      <li> Matti lataa rahaa 50 euroa</li>
      <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
    </ul>
<p>Pääohjelman runko on seuraava:</p>
    <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        LyyraKortti pekanKortti = new LyyraKortti(20);
        LyyraKortti matinKortti = new LyyraKortti(30);

        // kirjoita koodia tähän
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
<pre>
Pekka: Kortilla on rahaa 16.0 euroa
Matti: Kortilla on rahaa 27.5 euroa
Pekka: Kortilla on rahaa 36.0 euroa
Matti: Kortilla on rahaa 23.5 euroa
Pekka: Kortilla on rahaa 31.0 euroa
Matti: Kortilla on rahaa 73.5 euroa
</pre>
  </div>
</div>
  <h3>Lisää metodeja</h3>
  <p>Jatketaan taas <code>Henkilo</code>-luokan parissa. Päätetään että haluamme laskea henkilöiden painoindeksejä. Tätä varten teemme henkilölle metodit pituuden ja painon asettamista varten, sekä metodin joka laskee painoindeksin. Henkilön uudet ja muuttuneet osat seuraavassa:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;
    private int paino;
    private int pituus;

    public Henkilo(String nimiAlussa) {
        this.ika = 0;
        this.paino = 0;
        this.pituus = 0;
        this.nimi = nimiAlussa;
    }

    public void setPituus(int uusiPituus) {
        this.pituus = uusiPituus;
    }

    public void setPaino(int uusiPaino) {
        this.paino = uusiPaino;
    }

    public double painoIndeksi(){
        double pituusPerSata = this.pituus / 100.0;
        return this.paino / ( pituusPerSata * pituusPerSata );
    }

    // ...
}      
</pre>
  <p>Eli henkilölle lisättiin oliomuuttujat <code>pituus</code> ja <code>paino</code>. Näille voi asettaa arvon metodeilla <code>setPituus</code> ja <code>setPaino</code>. Jälleen käytössä Javaan vakiintunut nimeämiskäytäntö, eli jos metodin tehtävänä on ainoastaan asettaa arvo oliomuuttujaan, on metodi tapana nimetä <code>setMuuttujanNimi</code>:ksi. Arvon asettavia metodeja kutsutaan usein "settereiksi". Seuraavassa käytämme uusia metodeja:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo matti = new Henkilo("Matti");
    Henkilo juhana = new Henkilo("Juhana");

    matti.setPituus(180);
    matti.setPaino(86);

    juhana.setPituus(175);
    juhana.setPaino(64);

    System.out.println( matti.getNimi() + ", painoindeksisi on " + matti.painoIndeksi() );
    System.out.println( juhana.getNimi() + ", painoindeksisi on " + juhana.painoIndeksi() );
}
</pre>
<p>Tulostus:</p>
<pre>
Matti, painoindeksisi on 26.54320987654321
Juhana, painoindeksisi on 20.897959183673468
</pre>
  <h3>Parametrilla ja oliomuuttujalla sama nimi!</h3>
  <p>Edellä metodissa <code>setPituus</code> asetetaan oliomuuttujaan <code>pituus</code> parametrin <code>uusiPituus</code> arvo:</p>
  <pre class="sh_java">
public void setPituus(int uusiPituus) {
    this.pituus = uusiPituus;
}
</pre>
  <p>Parametrin nimi voisi olla myös sama kuin oliomuuttujan nimi, eli seuraava toimisi myös:</p>
  <pre class="sh_java">
public void setPituus(int pituus) {
    this.pituus = pituus;
}
</pre>
  <p>Nyt metodissa <code>pituus</code> tarkottaa nimenomaan <em>pituus</em>-nimistä parametria ja <code>this.pituus</code> saman nimistä oliomuuttujaa. Esim. seuraava ei toimisi sillä koodi ei viittaa ollenkaan oliomuuttujaan <em>pituus</em>:</p>
  <pre class="sh_java">
public void setPituus(int pituus) {
    // EI TOIMI ÄLÄ TEE NÄIN!!!
    pituus = pituus;
}
</pre>
  <h3>Liukuluvun "siisti" tulostaminen</h3>
  <p>Desimaalien määrä edellisessä tulostuksessa on hieman liioiteltu. Yksi tapa päästä määräämään tulostettavien desimaalien määrä on seuraava:</p>
  <pre class="sh_java">
System.out.println( matti.getNimi() + ", painoindeksisi on " + String.format( "%.2f", matti.painoIndeksi() ) );
System.out.println( juhana.getNimi() + ", painoindeksisi on " + String.format( "%.2f", juhana.painoIndeksi() ) );
</pre>
  <p>Eli jos <code>luku</code> on liukuluku, voi siitä tehdä komennolla <code>String.format( "%.2f", luku )</code> merkkijonon, jossa luku on otettu mukaan kahden desimaalin tarkkuudella. Pisteen ja f:n välissä oleva numero säätää mukaan tulevan desimaalien määrän. </p>
  <p>Nyt tulostus on siistimpi:</p>
<pre>
Matti, painoindeksisi on 26,54
Juhana, painoindeksisi on 20,90
</pre>
  <p><code>String.format</code> ei ehkä ole kaikkein monikäyttöisin tapa Javassa tulostuksen muotoiluun. Se kuitenkin lienee yksinkertaisin ja kelpaa meille hyvin nyt.</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3>Kello laskurin avulla</h3>
    <p>Tässä tehtävässä tehdään luokka <code>YlhaaltaRajoitettuLaskuri</code> ja sovelletaan sitä kellon tekemiseen.</p>
    <h4 class="req">Rajoitettu laskuri</h4>
    <p>Tehdään luokka <code>YlhaaltaRajoitettuLaskuri</code>. Luokan olioilla on seuraava toiminnallisuus:</p>
    <ul>
<li> Laskurilla on oliomuuttuja, joka muistaa laskurin arvon.
        Laskurin arvo on luku väliltä 0...yläraja.</li>
      <li> Aluksi laskurin arvo on 0.</li>
      <li> Olion konstruktori määrittää laskurin ylärajan.</li>
      <li> Metodi <code>seuraava</code> kasvattaa laskurin arvoa.
        Mutta jos laskurin arvo ylittää ylärajan, sen arvoksi tulee 0.</li>
      <li> Metodi <code>toString</code> palauttaa laskurin arvon merkkijonona.</li>
    </ul>
<p>Tehtäväpohjassa on valmiina pääohjelmaa varten tiedosto <code>Paaohjelma</code>. Aloita tekemällä luokka <code>YlhaaltaRajoitettuLaskuri</code> vastaavasti kuin LyyraKortti-tehtävässä. Näin tehdään myös tulevissa tehtäväsarjoissa.</p>
    <p>Luokan rungoksi tulee seuraava:</p>
    <pre class="sh_java">
public class YlhaaltaRajoitettuLaskuri {
    private int arvo;
    private int ylaraja;

    public YlhaaltaRajoitettuLaskuri(int ylarajanAlkuarvo) {
        // kirjoita koodia tähän
    }

    public void seuraava() {
        // kirjoita koodia tähän
    }

    public String toString() {
        // kirjoita koodia tähän
    }
}
</pre>
    <p><b>Vihje</b>: et voi palauttaa toStringissä suoraan kokonaislukutyyppisen oliomuuttujan <code>laskuri</code> arvoa. Kokonaislukumuuttujasta <code>arvo</code> saa merkkijonomuodon esim. lisäämällä sen eteen tyhjän merkkijonon eli kirjoittamalla <code>"" + arvo</code>.</p>
    <p>Seuraavassa on pääohjelma, joka käyttää laskuria:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        YlhaaltaRajoitettuLaskuri laskuri = new YlhaaltaRajoitettuLaskuri(4);
        System.out.println("arvo alussa: " + laskuri );

        int i = 0; 
        while ( i &lt; 10) {
            laskuri.seuraava();
            System.out.println("arvo: " + laskuri );
            i++;
        }
    }
}
</pre>
    <p>Laskurille asetetaan konstruktorissa ylärajaksi 4, joten laskurin arvo on luku 0:n ja 4:n väliltä. Huomaa, miten metodi <code>seuraava</code> vie laskurin arvoa eteenpäin, kunnes se pyörähtää 4:n jälkeen 0:aan:</p>
    <p>Ohjelman tulostuksen tulisi olla seuraava:</p>
    <pre>
arvo alussa: 0
arvo: 1
arvo: 2
arvo: 3
arvo: 4
arvo: 0
arvo: 1
arvo: 2
arvo: 3
arvo: 4
arvo: 0
</pre>
    <h4 class="req">Etunolla tulostukseen</h4>
    <p>Tee <code>toString</code>-metodista sellainen, että se lisää arvon merkkijonoesitykseen etunollan, jos laskurin arvo on vähemmän kuin 10. Eli jos laskurin arvo on esim. 3, palautetaan merkkijono "03", jos arvo taas on esim. 12, palautetaan normaaliin tapaan merkkijono "12".</p>
    <p>Muuta pääohjelma seuraavaan muotoon ja varmista, että tulos on haluttu.</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        YlhaaltaRajoitettuLaskuri laskuri = new YlhaaltaRajoitettuLaskuri(14);
        System.out.println("arvo alussa: " + laskuri );

        int i = 0; 
        while ( i &lt; 16){
            laskuri.seuraava();
            System.out.println("arvo: " + laskuri );
            i++; 
        }
    }
}
</pre>
<pre>
arvo alussa: 00
arvo: 01
arvo: 02
arvo: 03
arvo: 04
arvo: 05
arvo: 06
arvo: 07
arvo: 08
arvo: 09
arvo: 10
arvo: 11
arvo: 12
arvo: 13
arvo: 14
arvo: 00
arvo: 01
</pre>
    <h4 class="req">Kello, ensimmäinen versio</h4>
    <p>Käyttämällä kahta laskuria voimme muodostaa kellon. Tuntimäärä on laskuri, jonka yläraja on 23, ja minuuttimäärä on laskuri jonka yläraja on 59. Kuten kaikki tietävät, kello toimii siten, että aina kun minuuttimäärä pyörähtää nollaan, tuntimäärä kasvaa yhdellä. </p>
    <p>Tee ensin laskurille metodi <code>arvo</code>, joka palauttaa laskurin arvon:</p>
    <pre class="sh_java">
public int arvo() {
    // kirjoita koodia tähän
}
</pre>
    <p>Tee sitten kello täydentämällä seuraava pääohjelmarunko (kopioi tämä pääohjelmaksesi sekä täydennä tarvittavilta osin kommenttien ohjaamalla tavalla):</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);     

        int i = 0;
        while ( i &lt; 121 ) {
            System.out.println( tunnit + ":" + minuutit);   // tulostetaan nykyinen aika
            // minuuttimäärä kasvaa
            // jos minuuttimäärä menee nollaan, tuntimäärä kasvaa

            i++;
        }
    }
}
</pre>
    <p>Jos kellosi toimii oikein, sen tulostus näyttää suunnilleen seuraavalta:</p>
<pre>
00:00
00:01
...
00:59
01:00
01:01
01:02
...
01:59
02:00
</pre>
    <h4>Kello, toinen versio</h4>
    <p>Laajenna kelloasi myös sekuntiviisarilla. Tee lisäksi luokalle <code>YlhaaltaRajoitettuLaskuri</code> metodi <code>asetaArvo</code>, jolla laskurille pystyy asettamaan halutun arvon. Jos laskurille yritetään asettaa kelvoton arvo eli negatiivinen luku tai ylärajaa suurempi luku, ei laskurin arvo muutu.</p>
    <p>Tämän metodin avulla voit muuttaa kellon ajan heti ohjelman alussa haluamaksesi.</p>
    <p>Voit testata kellon toimintaa seuraavalla ohjelmalla</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args)  {
        Scanner lukija = new Scanner(System.in);
        YlhaaltaRajoitettuLaskuri sekunnit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);

        System.out.print("sekunnit: ");
        int sek = // kysy sekuntien alkuarvo käyttäjältä
        System.out.print("minuutit: ");
        int min = // kysy minuuttien alkuarvo käyttäjältä
        System.out.print("tunnit: ");
        int tun = // kysy tuntien alkuarvo käyttäjältä

        sekunnit.asetaArvo(sek);
        minuutit.asetaArvo(min);
        tunnit.asetaArvo(tun);

        int i = 0;
        while ( i &lt; 121 ) {
            // lisää edelliseen myös sekuntiviisari
            i++;
        }

    }
}
</pre>
    <p>Kokeile laittaa kellosi alkamaan ajasta <i>23:59:50</i> ja varmista, että vuorokauden vaihteessa kello toimii odotetusti!</p>
    <p><strong>Bonus-tehtävä: ikuisesti käyvä kello (tehtävää ei palauteta!)</strong></p>
    <p>Ennen kuin alat tekemään tätä tehtävää, palauta jo tekemäsi kello!</p>
    <p>Muuta pääohjelmasi seuraavaan muotoon:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) throws Exception {
        YlhaaltaRajoitettuLaskuri sekunnit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);

        sekunnit.asetaArvo(50);
        minuutit.asetaArvo(59);
        tunnit.asetaArvo(23);

        while ( true ) {
            System.out.println( tunnit + ":" + minuutit + ":" + sekunnit );
            Thread.sleep(1000);
            // lisää kellon aikaa sekunnilla eteenpäin
        }
    }
}
</pre>
    <p>Nyt kello käy ikuisesti ja kasvattaa arvoaan sekunnin välein. Sekunnin odotus tapahtuu komennolla <code>Thread.sleep(1000);</code>, komennon parametri kertoo nukuttavan ajan millisekunteina. Jotta komento toimisi, pitää main:in esittelyriville tehdä pieni lisäys: <code>public static void main(String[] args) <b>throws Exception</b> {</code>, eli tummennettuna oleva <code>throws Exception</code>.</p>
    <p>Saat ohjelman lopetettua painamalla NetBeans-konsolin (eli sen osan johon kello tulostaa arvonsa) vasemmalla laidalla olevasta punaisesta laatikosta.</p>
  </div>
</div>
  <p><big><b>Tärkeitä kommentteja liittyen olioiden käyttöön. Lue nämä ehdottomasti.</b></big></p>
  <p>Olio-ohjelmoinnissa on kyse pitkälti käsitteiden eristämisestä omiksi kokonaisuuksikseen tai toisin ajatellen abstraktioiden muodostamisesta. Voisi ajatella, että on turha luoda oliota jonka sisällä on ainoastaan luku, eli että saman voisi tehdä suoraan <code>int</code>-muuttujilla. Asia ei kuitenkaan ole näin. Jos kello koostuu pelkästään kolmesta int-muuttujasta joita kasvatellaan, muuttuu ohjelma lukijan kannalta epäselvemmäksi, koodista on vaikea "nähdä" mistä on kysymys. Aiemmin materiaalissa mainitsimme jo kokeneen ja kuuluisan ohjelmoijan Kent Beckin neuvon <em>"Any fool can write code that a computer can understand.  Good programmers write code that humans can understand"</em>, eli koska viisari on oikeastaan oma selkeä käsitteensä, on siitä ohjelman ymmärrettävyyden parantamiseksi hyvä tehdä oma luokka, eli <code>YlhaaltaRajoitettuLaskuri</code>.</p>
  <p>Käsitteen erottaminen omaksi luokaksi on monellakin tapaa hyvä idea. Ensinnäkin tiettyjä yksityiskohtia (esim. laskurin pyörähtäminen) saadaan piilotettua luokan sisään (eli <em>abstrahoitua</em>). Sen sijaan että kirjoitetaan if-lause ja sijoitusoperaatio, riittää, että laskurin käyttäjä kutsuu selkeästi nimettyä metodia <code>seuraava()</code>. Aikaansaatu laskuri sopii kellon lisäksi ehkä muidenkin ohjelmien rakennuspalikaksi, eli selkeästä käsitteestä tehty luokka voi olla monikäyttöinen. Suuri etu saavutetaan myös sillä, että koska laskurin toteutuksen yksityiskohdat eivät näy laskurin käyttäjille, voidaan yksityiskohtia tarvittaessa muuttaa.</p>
  <p>Totesimme että kello sisältää kolme viisaria, eli koostuu kolmesta käsitteestä. Oikeastaan kello on itsekin käsite ja teemme ensi viikolla luokan Kello, jotta voimme luoda selkeitä Kello-olioita. Kello tulee siis olemaan olio jonka toiminta perustuu "yksinkertaisimpiin" olioihin eli viisareihin. Tämä on juuri olio-ohjelmoinnin suuri idea: ohjelma rakennetaan pienistä selkeistä yhteistoiminnassa olevista olioista. </p>
  <p>Nyt otamme varovaisia ensiaskelia oliomaailmassa. Kurssin lopussa oliot alkavat kuitenkin olla jo selkärangassa ja nyt ehkä käsittämättömältä tuntuva lausahdus, <em>ohjelma rakennetaan pienistä selkeistä yhteistoiminnassa olevista olioista</em> alkaa tuntua meistä ehkä järkeenkäyvältä ja itsestäänselvältä.</p>
  <h3>Oman metodin kutsu</h3>
  <p>Olio voi kutsua myös omia metodeitaan. Jos esim. halutaan, että toString-metodin palauttama merkkijonoesitys kertoisi myös henkilön painoindeksin, kannattaa <code>toString</code>:istä kutsua olion omaa metodia <code>painoIndeksi</code>:</p>
  <pre class="sh_java">
public String toString() {
    return this.nimi + ", ikä " + this.ika + " vuotta, painoindeksini on " + this.painoIndeksi();
}
</pre>
  <p>Eli kun olio kutsuu omaa metodiaan, riittää etuliite this ja pelkkä metodin nimi. Vaihtoehtoinen tapa on tehdä oman metodin kutsu muodossa <code>painoIndeksi()</code> jolloin ei korosteta, että kutsutaan "olion itsensä" metodia painoindeksi:</p>
  <pre class="sh_java">
public String toString() {
    return this.nimi + ", ikä " + this.ika + " vuotta, painoindeksini on " + painoIndeksi();
}
</pre>
  <p>Olioscreencastin kolmas osa:</p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=YKwzIGuCLn8" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> 
  
  <!--
<p><iframe allowfullscreen="" frameborder="0" height="450" width="700" src="http://www.youtube.com/embed/owhvYkDTX2g"></iframe></p>
-->
  
  <p>Nyt on aika harjoitella lisää yksinkertaisten olioiden tekemistä käytännössä:</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3>Lukutilasto</h3>
    <h4 class="req">Lukujen määrä</h4>
    <p>Tee luokka <code>Lukutilasto</code> (tiedosto luomaasi luokkaa varten on tehtäväpohjassa valmiina), joka tuntee seuraavat toiminnot :</p>
    <ul>
<li> metodi <code>lisaaLuku</code> lisää uuden luvun tilastoon
      </li>
<li> metodi <code>haeLukujenMaara</code> kertoo lisättyjen lukujen määrän
    </li>
</ul>
<p>Luokan ei tarvitse tallentaa mihinkään lisättyjä lukuja, vaan riittää muistaa niiden määrä. Metodin <code>lisaaLuku</code> ei tässä vaiheessa tarvitse edes ottaa huomioon, mikä luku lisätään tilastoon, koska ainoa tallennettava asia on lukujen määrä.</p>
    <p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
public class Lukutilasto {
    private int lukujenMaara;

    public Lukutilasto() {
        // alusta tässä muuttuja lukujenMaara
    }

    public void lisaaLuku(int luku) {
        // kirjoita koodia tähän
    }

    public int haeLukujenMaara() {
        // kirjoita koodia tähän
    }
}
</pre>
    <p>Seuraava ohjelma esittelee luokan käyttöä:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Lukutilasto tilasto = new Lukutilasto();
        tilasto.lisaaLuku(3);
        tilasto.lisaaLuku(5);
        tilasto.lisaaLuku(1);
        tilasto.lisaaLuku(2);
        System.out.println("Määrä: " + tilasto.haeLukujenMaara());
    }
}
</pre>
    <p>Ohjelman tulostus on seuraava:</p>
<pre>
Määrä: 4
</pre>
    <h4 class="req">Summa ja keskiarvo</h4>
    <p>Laajenna luokkaa seuraavilla toiminnoilla:</p>
    <ul>
<li> metodi <code>summa</code> kertoo lisättyjen lukujen summan (tyhjän lukutilaston summa on 0)
      </li>
<li> metodi <code>keskiarvo</code> kertoo lisättyjen lukujen keskiarvon (tyhjän lukutilaston keskiarvo on 0)
    </li>
</ul>
<p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
public class Lukutilasto {
    private int lukujenMaara;
    private int summa;

    public Lukutilasto() {
        // alusta tässä muuttujat maara ja summa
    }

    public void lisaaLuku(int luku) {
        // kirjoita koodia tähän
    }

    public int haeLukujenMaara() {
        // kirjoita koodia tähän
    }

    public int summa() {
        // kirjoita koodia tähän
    }

    public double keskiarvo() {
        // kirjoita koodia tähän
    }
}
</pre>
    <p>Seuraava ohjelma esittelee luokan käyttöä:</p>
    <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Lukutilasto tilasto = new Lukutilasto();
        tilasto.lisaaLuku(3);
        tilasto.lisaaLuku(5);
        tilasto.lisaaLuku(1);
        tilasto.lisaaLuku(2);
        System.out.println("Määrä: " + tilasto.haeLukujenMaara());
        System.out.println("Summa: " + tilasto.summa());
        System.out.println("Keskiarvo: " + tilasto.keskiarvo());
    }
}
</pre>
    <p>Ohjelman tulostus on seuraava:</p>
<pre>
Määrä: 4
Summa: 11
Keskiarvo: 2.75
</pre>
    <h4 class="req">Summa käyttäjältä</h4>
    <p>Tee ohjelma, joka kysyy lukuja käyttäjältä, kunnes käyttäjä antaa luvun -1. Sitten ohjelma ilmoittaa lukujen summan.</p>
    <p>Ohjelmassa tulee käyttää <code>Lukutilasto</code>-olioa summan laskemiseen.</p>
    <pre>
Anna lukuja:
<font color="red">4</font>
<font color="red">2</font>
<font color="red">5</font>
<font color="red">4</font>
<font color="red">-1</font>
Summa: 15
</pre>
    <h4>Monta summaa</h4>
    <p>Muuta edellistä ohjelmaa niin, että ohjelma laskee myös  parillisten ja parittomien lukujen summaa.</p>
    <p><b>HUOM</b>: Määrittele ohjelmassa <i>kolme</i> oliota luokasta <code>Lukutilasto</code>: ensimmäinen laskee kaikkien summan, toinen laskee parillisten lukujen summan ja kolmas laskee parittomien lukujen summan.</p>
    <p><b>Jotta testi toimisi, on oliot luotava pääohjelmassa edellä mainitussa järjestyksessä (eli ensin kaikkien summan laskeva olio, toisena parillisten summan laskeva ja viimeisenä parittomien summan laskeva olio)!</b></p>
    <p>Ohjelman tulee toimia seuraavasti:</p>
<pre>
Anna lukuja:
<font color="red">4</font>
<font color="red">2</font>
<font color="red">5</font>
<font color="red">2</font>
<font color="red">-1</font>
Summa: 13
Parillisten summa: 8
Parittomien summa: 5
</pre>
</div>
</div>
  <h2>Satunnaisuus</h2>
  <p>Ohjelmoidessa satunnaisuutta tarvitaan silloin tällöin. Satunnaisuutta -- esimerkiksi sään arvaamattomuutta tai tietokoneen tietokonepeleissä tekemien yllättäviä siirtoja -- voidaan useimmiten simuloida tietokoneelta pyydettävien satunnaislukujen avulla. Satunnaislukujen pyytäminen onnistuu käyttäen Javasta löytyvää <code>Random</code>-luokkaa. Random-luokkaa voi käyttää seuraavalla tavalla.</p>
  <pre class="sh_java">
import java.util.Random;

    public class Arvontaa {
        public static void main(String[] args) {
        Random arpoja = new Random(); // luodaan arpoja apuväline
        int i = 0;

        while (i &lt; 10) {
            // Arvotaan ja tulostetaan jokaisella kierroksella satunnainen luku
            System.out.println(arpoja.nextInt(10)); 
            i++;
        }
    }
}
</pre>
  <p>Yllä olevassa koodissa luodaan ensin <code>Random</code>-luokan ilmentymä käyttäen avainsanaa <code>new</code> -- samoin kuin muitakin olioita luodessa. Random-olio tarjoaa metodin <code>nextInt</code>, jolle annetaan parametrina kokonaisluku. Metodi palauttaa satunnaisen kokonaisluvun väliltä <em>0..(annettu kokonaisluku - 1)</em>.</p>
  <p>Ohjelman tulostus voisi olla vaikka seuraavanlainen:</p>
<pre>
2
2
4
3
4
5
6
0
7
8
</pre>
  <p>Tarvitsemme liukulukuja esimerkiksi todennäköisyyslaskennan yhteydessä. Tietokoneella todennäköisyyksiä simuloidaan yleensä väliltä [0..1] olevilla luvuilla.  Random-oliolta saa satunnaisia liukulukuja metodilla <code>nextDouble</code>. Tarkastellaan seuraavia säämahdollisuuksia:</p>
  <ul>
<li>Sataa räntää todennäköisyydellä 0.1 (10%)</li>
    <li>Sataa lunta todennäköisyydellä 0.3 (30%)</li>
    <li>Aurinko paistaa todennäköisyydellä 0.6 (60%)</li>
  </ul>
<p>Luodaan edellä olevista arvioista sääennustaja.</p>
  <pre class="sh_java">
import java.util.ArrayList;
import java.util.Random;

public class SaaEnnustaja {
    private Random random;

    public SaaEnnustaja() {
        this.random = new Random();
    } 

    public String ennustaSaa() {
        double todennakoisyys = this.random.nextDouble();

        if (todennakoisyys &lt;= 0.1) {
            return "Sataa räntää";
        } else if (todennakoisyys &lt;= 0.4) { // 0.1 + 0.3
            return "Sataa lunta";
        } else { // loput, 1.0 - 0.4 = 0.6
            return "Aurinko paistaa";
        } 
    }

    public int ennustaLampotila() {
        return (int) ( 4 * this.random.nextGaussian() - 3 ); 
    }
}
</pre>
  <p>Metodi <code>ennustaLampotila</code> on monella tapaa mielenkiintoinen. Metodin sisällä tehtävä kutsu <code>this.random.nextGaussian()</code> on tavallinen metodikutsu, jonka kaltaisia olemme nähneet aikaisemminkin. Kiinnostavaa tässä <code>Random</code>-luokan ilmentymän tarjoamassa metodissa on se, että metodin palauttama luku on <em>normaalijakautunut</em> (jos et koe mielenkiintoa satunnaisuuden eri lajeihin se ei haittaa!).</p>
  <pre class="sh_java">
public int ennustaLampotila() {
    return (int) ( 4 * this.random.nextGaussian() - 3 ); 
}
</pre>
  <p>Edellisessä lausekkeessa kiinnostava on myös osa <code>(int)</code>. Tämä kohta lausekkeessa muuttaa suluissa olevan liukuluvun kokonaisluvuksi. Vastaavalla menetelmällä voidaan muuttaa myös kokonaislukuja liukuluvuiksi kirjoittamalla <code>(double) kokonaisluku</code>. Tätä kutsutaan <em>eksplisiittiseksi tyyppimuunnokseksi</em>.</p>
  <p>Luodaan vielä pääohjelma josta luokkaa <code>SaaEnnustaja</code> käytetään.</p>
  <pre class="sh_java">
public class Ohjelma {

    public static void main(String[] args) {
        SaaEnnustaja ennustaja = new SaaEnnustaja();

        // käytetään listaa apuvälineenä
        ArrayList&lt;String&gt; paivat = new ArrayList&lt;String&gt;();
        Collections.addAll(paivat, "Ma", "Ti", "Ke", "To", "Pe", "La", "Su");

        System.out.println("Seuraavan viikon sääennuste:");
        for(String paiva : paivat) {
            String saaEnnuste = ennustaja.ennustaSaa();
            int lampotilaEnnuste = ennustaja.ennustaLampotila(); 

            System.out.println(paiva + ": " + saaEnnuste + " " + lampotilaEnnuste + " astetta.");
        }
    }
}
</pre>
  <p>Ohjelman tulostus voisi olla esimerkiksi seuraavanlainen:</p>
<pre>
Seuraavan viikon sääennuste:
Ma: Sataa lunta 1 astetta.
Ti: Sataa lunta 1 astetta.
Ke: Aurinko paistaa -2 astetta.
To: Aurinko paistaa 0 astetta.
Pe: Sataa lunta -3 astetta.
La: Sataa lunta -3 astetta.
Su: Aurinko paistaa -5 astetta
</pre>
  <div id="viikko4" class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Nopan heittäminen</h3>
    <p> Tehtäväpohjassa on luokka <code>Noppa</code>, jolla on seuraavat toiminnot:</p>
    <ul>
<li> konstruktori <code>Noppa(int tahkojenMaara)</code> luo uuden noppa-olion annetulla nopan tahkojen (eri oman numeronsa sisältämien "puolien") määrällä</li>
      <li> metodi <code>heita</code> kertoo nopanheiton tuloksen (tulos riippuu tahkojen määrästä)</li>
    </ul>
<p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
import java.util.Random;

public class Noppa {
    private Random random = new Random();
    private int tahkojenMaara;

    public Noppa(int tahkojenMaara) {
      // Alusta muuttuja tahkojenMaara tässä
    }

    public int heita() {
        // arvotaan luku väliltä 1-tahkojenMaara
    }
}
</pre>
    <p>Täydennä luokkaa <code>Noppa</code> siten, että noppa palauttaa jokaisella heitolla arvotun luvun väliltä <code>1...tahkojen määrä</code>. Seuraavassa noppaa testaava pääohjelma: </p>
    <pre class="sh_java">
public class Ohjelma {
    public static void main(String[] args) {
        Noppa noppa = new Noppa(6);

        int i = 0;
        while ( i &lt; 10 ) {
            System.out.println( noppa.heita() );
            i++;
          }
    }
}
</pre>
    <p>Tulostus voisi olla esimerkiksi seuraava:</p>
<pre>
1
6
3
5
3
3
2
2
6
1
</pre>
</div>
<div class="tehtava">
    <h3>Salasanan arpoja</h3>
    <p>Tehtävänäsi on täydentää luokkaa <code>SalasananArpoja</code>, jossa on seuraavat toiminnot:</p>
    <ul>
<li> konstruktori <code>SalasananArpoja</code> luo uuden olion, joka käyttää annettua salasanan pituutta</li>
      <li> metodi <code>luoSalasana</code> palauttaa uuden, merkeistä a-z muodostetun konstruktorin parametrin määräämän pituisen salasanan </li>
    </ul>
<p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
import java.util.Random;

public class SalasananArpoja {
    // Määrittele muuttuja tässä

    public SalasananArpoja(int pituus) {
        // Alusta muuttuja tässä
    }

    public String luoSalasana() {
        // Kirjoita tähän koodi, joka palauttaa uuden salasanan
    }
}
</pre>
    <p>Seuraavassa ohjelma joka käyttää SalasananArpoja-olioa:</p>
    <pre class="sh_java">
public class Ohjelma {
    public static void main(String[] args) {
        SalasananArpoja arpoja = new SalasananArpoja(13);
        System.out.println("Salasana: " + arpoja.luoSalasana());
        System.out.println("Salasana: " + arpoja.luoSalasana());
        System.out.println("Salasana: " + arpoja.luoSalasana());
        System.out.println("Salasana: " + arpoja.luoSalasana());
    }
}
</pre>
    <p>Ohjelman tulostus voisi näyttää seuraavalta:</p>
<pre>
Salasana: mcllsoompezvs
Salasana: urcxboisknkme
Salasana: dzaccatonjcqu
Salasana: bpqmedlbqaopq
</pre>
    <p><b>Vihje1:</b> näin muutat kokonaisluvun <tt>luku</tt> kirjaimeksi:</p>
<pre class="sh_java">
int luku = 17;
char merkki = "abcdefghijklmnopqrstuvxyz".charAt(luku);
</pre>
    <p><b>Vihje2:</b> tehtävän 78 vihjeestä lienee tässäkin tehtävässä apua.</p>
  </div>
  <div class="tehtava">
    <h3>Lottoarvonta</h3>
    <p>Tehtävänäsi on täydentää luokkaa <code>LottoRivi</code>, joka arpoo viikon lottonumerot. Lottonumerot ovat väliltä 1–39 ja niitä arvotaan 7. Lottorivi koostuu siis 7:stä eri numerosta väliltä 1–39. Luokassa on seuraavat toiminnot:</p>
    <ul>
<li> konstruktori <code>LottoRivi</code> luo uuden LottoRivi-olion joka sisältää uudet, arvotut numerot</li>
      <li> metodi <code>numerot</code> palauttaa tämän lottorivin lottonumerot</li>
      <li> metodi <code>arvoNumerot</code> arpoo riville uudet numerot</li>
      <li> metodi <code>sisaltaaNumeron</code> kertoo onko arvotuissa numeroissa annettu numero</li>
    </ul>
<p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
import java.util.ArrayList;
import java.util.Random;

    public class LottoRivi {
    private ArrayList&lt;Integer&gt; numerot;

    public LottoRivi() {
        // Alustetaan lista numeroille
        this.numerot = new ArrayList&lt;Integer&gt;();
        // Arvo numerot heti LottoRivin luomisen yhteydessä
        this.arvoNumerot();
    }

    public ArrayList&lt;Integer&gt; numerot() {
        return this.numerot;
    }

    public void arvoNumerot() {
        // Kirjoita numeroiden arvonta tänne käyttämällä metodia sisaltaaNumeron()
    }

    public boolean sisaltaaNumeron(int numero) {
        // Testaa tässä onko numero jo arvottujen numeroiden joukossa
    }
}
</pre>
    <p>Tehtäväpohjan mukana tulee seuraava pääohjelma:</p>
    <pre class="sh_java">
import java.util.ArrayList;

    public class Ohjelma {
        public static void main(String[] args) {
        LottoRivi lottoRivi = new LottoRivi();
        ArrayList&lt;Integer&gt; lottonumerot = lottoRivi.numerot();

        System.out.println("Lottonumerot:");
        for (int numero : lottonumerot) {
            System.out.print(numero + " ");
        }
        System.out.println("");
    }
}
</pre>
    <p>Ohjelman mahdollisia tulostuksia ovat seuraavat:</p>
<pre>
Lottonumerot:
3 5 10 14 15 27 37
</pre>
<pre>
Lottonumerot:
2 9 11 18 23 32 34
</pre>
    <p><strong>Huom!</strong> Sama numero saa esiintyä lottorivissä vain kerran.</p>
  </div>
  <div class="tehtava">
    <h3>Viikon huipennus: hirsipuun logiikka</h3>
    <p>Hirsipuu-pelistä pitävä kaverisi ohjelmoi hirsipuupelin joka näyttää seuraavalta.</p>
    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/hirsipuu-tikkuukko.png"></p>
    <p>Hänen koneestaan hajosi kovalevy, eikä hän ollut tehnyt <a href="http://fi.wikipedia.org/wiki/Varmuuskopiointi" target="_blank"><em>varmuuskopiota</em></a>. Hän on kuitenkin luvannut pelin lahjaksi pikkuveljelleen, ja aikataulukiireidensä takia tarvitsee apuasi pelin toteutukseen. Tässä tehtäväsarjassa toteutat kaverisi hirsipuu-pelille arvauslogiikan ja annetun sanan salaamisen.</p>
    <p>Kaverisi on luonut pelille käyttöliittymän sekä valmiin rungon sovelluksen logiikkaan. Kun lataat projektin TMC:ltä, näet käyttöliittymä- ja testiluokkien lisäksi allaolevan ohjelmarungon.</p>
    <pre class="sh_java">
public class HirsipuuLogiikka {

    private String sana;
    private String arvatutKirjaimet;
    private int virheidenLukumaara;

    public HirsipuuLogiikka(String sana) {
        this.sana = sana.toUpperCase();
        this.arvatutKirjaimet = "";
        this.virheidenLukumaara = 0;
    }

    public int virheidenLukumaara() {
        return this.virheidenLukumaara;
    }

    public String arvatutKirjaimet() {
        return this.arvatutKirjaimet;
    }

    public int virheitaHavioon() {
        return 12;
    }

    public void arvaaKirjain(String kirjain) {
        // Ohjelmoi tänne toiminnallisuus kirjaimen arvaamiseksi.

        // Arvattua kirjainta ei saa arvata uudestaan. Jos arvattava sana 
        // ei sisällä kirjainta, virheiden lukumäärän tulee kasvaa.
        // Lisää arvattu kirjain arvattuihin kirjaimiin

    }

    public String salattuSana() {
        // Ohjelmoi tänne toiminnallisuus salatun sanan luomiseksi
        // ja antamiseksi. 

        // Luo uusi salattu sana this.sana-merkkijonoa kirjain kirjaimelta 
        // läpikäyden. Jos kirjain on arvatuissa kirjaimissa, voit lisätä sen 
        // sellaisenaan. Jos ei, lisää uuteen sanaan merkki "_".

        // Muista varmistaa ettet ohjelmoi päättymätöntä toistolauseketta!

        // palauta lopuksi salattua sanaa kuvaava merkkijono.

        return "";
    }
}
</pre>
    <p>Tässä tehtävässä <em>sinun tulee lisätä toiminnallisuutta vain luokan <code>HirsipuuLogiikka</code> metodeihin <code>arvaaKirjain(String kirjain)</code> ja <code>salattuSana()</code></em>.</p>
    <p><strong>Logiikan testaaminen</strong></p>
    <p>Tehtäväpohja sisältää <em>kaksi</em> testiluokkaa. Luokka <code>Main</code> käynnistää kaverisi toteuttaman graafisen version pelistä. Luokkaa <code>Testiohjelma</code> taas voit käyttää <code>HirsipuuLogiikka</code>-luokan testaamiseen.</p>
    <h4>Kirjaimen arvaaminen</h4>
    <p>Muokkaa tässä tehtävässä vain metodin <code>arvaaKirjain(String kirjain)</code> toiminnallisuutta.</p>
    <p>Kun käyttäjä arvaa jonkin kirjaimen, kutsuu hirsipuun käyttöliittymä hirsipuulogiikan metodia <code>arvaaKirjain</code> jonka tulee tarkistaa onko arvattava kirjain jo arvattujen kirjainten (joita hirsipuulogiikka säilyttää oliomuuttujassa <code>this.arvatutKirjaimet</code>) joukossa. Jos kirjain on jo arvattujen kirjainten joukossa, metodin ei tule tehdä mitään. Jos arvattavaa kirjainta ei ole arvattu aiemmin, on tarkastettava onko se arvattavassa sanassa (jota hirsipuulogiikka säilyttää oliomuuttujassa <code>this.sana</code>). Jos ei, virheiden lukumäärää (oliomuuttuja <code>this.virheidenLukumaara</code>) pitää kasvattaa yhdellä. Arvattu kirjain pitää lopuksi lopuksi osaksi arvattuja kirjaimia, jos se ei ole jo siellä.</p>
    <p>Esimerkki <code>arvaaKirjain</code>-metodin toiminnasta:</p>
    <pre class="sh_java">
HirsipuuLogiikka l = new HirsipuuLogiikka("kissa");
System.out.println("Arvataan: A, D, S, F, D");
l.arvaaKirjain("A");   // oikea
l.arvaaKirjain("D");   // väärä
l.arvaaKirjain("S");   // oikea
l.arvaaKirjain("F");   // väärä
l.arvaaKirjain("D");   // Tämän ei pitäisi kasvattaa virheiden lukumäärää koska D oli jo arvattu
System.out.println("Arvatut kirjaimet: "+l.arvatutKirjaimet());
System.out.println("Virheiden lukumäärä: "+l.virheidenLukumaara());
</pre>
<pre>
Arvataan: A, D, S, F, D
Arvatut kirjaimet: ADSF
Virheiden lukumäärä: 2
</pre>
<h4>Salatun sanan luominen</h4>
    <p>Hirsipuun käyttöliittymä näyttää käyttäjälle salatun muodon arvattavana olevasta sanasta. Yllä olevassa kuvassa salattu sana on <code>METO_I</code>, eli arvattavana olevasta sanasta näytetään vain arvatut kirjaimet, muut korvataan alaviivalla. Salatun sanan muodostaa hirsipuulogiikan metodi <code>salattuSana()</code> jonka sisältöä tässä tehtävässä on tarkoitus muokata.</p>
    <p>Salattu sana luodaan luomalla arvattavasta sanasta (<code>this.sana</code>) uusi versio. Jokainen kirjain jota ei ole vielä arvattu tulee vaihtaa merkkiin "_". Jos kirjain on jo arvattu, eli se löytyy arvatuista kirjaimista, voidaan se lisätä sellaisenaan salattuun sanaan.</p>
    <p>Avainsanoista <code>while</code>, <code>charAt</code> ja <code>contains</code> lienee tästä hyötyä. Saat muutettua yksittäisen merkin merkkijonoksi seuraavasti:</p>
    <pre class="sh_java">
  char merkki = 'a';
  String merkkijono = "" + merkki;
</pre>
    <p>Esimerkki metodin toiminnasta:</p>
    <pre class="sh_java">
HirsipuuLogiikka l = new HirsipuuLogiikka("kissa");
System.out.println("Sana on: "+l.salattuSana());

System.out.println("Arvataan: A, D, S, F, D");
l.arvaaKirjain("A");
l.arvaaKirjain("D");
l.arvaaKirjain("S");
l.arvaaKirjain("F");
l.arvaaKirjain("D");
System.out.println("Arvatut kirjaimet: "+l.arvatutKirjaimet());
System.out.println("Virheiden lukumäärä: "+l.virheidenLukumaara());
System.out.println("Sana on: "+l.salattuSana());
</pre>
<pre>
Sana on: _____
Arvataan: A, D, S, F, D
Arvatut kirjaimet: ADSF
Virheiden lukumäärä: 2
Sana on: __SSA
</pre>
    <p>Testaa lopuksi sinun ja kaverisi yhteistyössä tekemää ohjelmaa <code>Main</code>-luokan avulla! Voit muuttaa arvattavaa sanaa muuttamalla HirsipuuLogiikka-luokan konstruktorille parametrina annettavaa merkkijonoa:</p>
    <pre class="sh_java">
HirsipuuLogiikka logiikka = new HirsipuuLogiikka("parametri");
HirsipuuIkkuna peliIkkuna = new HirsipuuIkkuna(logiikka);
peliIkkuna.pelaa();
</pre>
    <p>Peliä pelataan näppäimistöltä, pelin voi lopettaa painamalla peli-ikkunan vasemmassa yläkulmassa olevaa x-merkkiä.</p>
  </div>
</div>
</div>
</section>