<section class="viikkoraja" id="5"><div class="viikkoraja">Viikko 5</div>
<div class="viikkoraja-mooc" id="Viikko 5" deadline="24.3.2013 23.59" data-first-chapter-index="23" data-first-exercise-index="84" data-first-week-index="5" data-first-chapter-index-mooc="23" data-first-exercise-index-mooc="84" data-first-week-index-mooc="5" tekija="Arto Vihavainen, Matti Luukkainen">


<h2>Lisää luokista ja olioista</h2>
<h3>Useita konstruktoreja</h3>
<p>Palataan jälleen henkilöitä käsittelevän luokan pariin. Luokka <code>Henkilo</code> näyttää tällä hetkellä seuraavalta:</p>
<pre class="sh_java">
public class Henkilo {

    private String nimi;
    private int ika;
    private int pituus;
    private int paino;

    public Henkilo(String nimi) {
        this.nimi = nimi;
        this.ika = 0;
        this.paino = 0;
        this.pituus = 0;
    }

    public void tulostaHenkilo() {
        System.out.println(this.nimi + " olen " + this.ika + " vuotta vanha");
    }

    public void vanhene() {
        this.ika++;
    }

    public boolean taysiIkainen(){
        if ( this.ika &lt; 18 ) {
            return false;
        }

        return true;
    }

    public double painoindeksi(){
        double pituusMetreina = this.pituus/100.0;

        return this.paino / (pituusMetreina*pituusMetreina);
    }

    public String toString(){
        return this.nimi + " olen " + this.ika + " vuotta vanha, painoindeksini on " + this.painoindeksi();
    }

    public void setPituus(int pituus){
        this.pituus = pituus;
    }

    public int getPituus(){
        return this.pituus;
    }

    public int getPaino() {
        return this.paino;
    }

    public void setPaino(int paino) {
        this.paino = paino;
    }

    public String getNimi(){
        return this.nimi;
    }
}
</pre>
<p>Kaikki henkilöoliot ovat luontihetkellä 0-vuotiaita, sillä konstruktori asettaa uuden henkilön ika-oliomuuttujan arvoksi 0:</p>
<pre class="sh_java">
public Henkilo(String nimi) {
    this.nimi = nimi;
    this.ika = 0;
    this.paino = 0;
    this.pituus = 0;
}
</pre>
<p>Haluaisimme myös luoda henkilöitä siten, että nimen lisäksi konstruktorin parametrina annettaisiin ikä. Tämä onnistuu helposti, sillä konstruktoreja voi olla useita. Tehdään vaihtoehtoinen konstruktori. Vanhaa konstruktoria ei tarvise poistaa. </p>
<pre class="sh_java">
public Henkilo(String nimi) {
    this.nimi = nimi;
    this.ika = 0;
    this.paino = 0;
    this.pituus = 0;
}

public Henkilo(String nimi, int ika) {
    this.nimi = nimi;
    this.ika = ika;
    this.paino = 0;
    this.pituus = 0;
}
</pre>
<p>Nyt olioiden luonti onnistuu kahdella vaihtoehtoisella tavalla:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);
    Henkilo esko = new Henkilo("Esko");

    System.out.println( pekka );
    System.out.println( esko );
}
</pre>
<pre>
Pekka, ikä 24 vuotta
Esko, ikä 0 vuotta
</pre>
<p>Tekniikkaa jossa luokalla on kaksi konstruktoria, kutsutaan <em>konstruktorin kuormittamiseksi</em>. Luokalla voi siis olla useita konstruktorjea, jotka poikkeavat toisistaanparametriensa määrältä tai tyypeiltä. Ei kuitenkaan ole mahdollista tehdä kahta erilaista konstruktoria joilla on täysin saman tyyppiset parametrit. Emme siis voi edellisten lisäksi lisätä konstruktoria <code>public Henkilo(String nimi, int paino)</code> sillä Javan on mahdoton erottaa tätä kaksiparametrisesta konstruktorissa, jossa luku tarkoittaa ikää.</p>
<h3>Oman konstruktorin kutsuminen</h3>
<p>Mutta hetkinen, luvussa 21 todettiin että "copy-paste"-koodi ei ole hyvä idea. Kun tarkastellaan edellä tehtyjä kuormitettuja konstruktoreita, niissä on aika paljon samaa. Emme ole oikein tyytyväisiä tilanteeseen.</p>
<p>Konstruktoreista ylempi on oikeastaan alemman erikoistapaus. Entä jos ylempi konstruktori voisi "kutsua" alempaa konstruktoria? Tämä onnistuu, sillä konstruktorin sisältä voi kutsua toista konstruktoria juuri tähän olioon liittyvän <code>this</code>-ilmauksen avulla!</p>
<p>Muutetaan ylempää konstruktoria siten, että se ei itse tee mitään vaan ainoastaan kutsuu alempaa konstruktoria ja pyytää sitä asettamaan iäksi 0:</p>
<pre class="sh_java">
public Henkilo(String nimi) {
    this(nimi, 0);  // suorita tässä toisen konstruktorin koodi ja laita ika-parametrin arvoksi 0
}

public Henkilo(String nimi, int ika) {
    this.nimi = nimi;
    this.ika = ika;
    this.paino = 0;
    this.pituus = 0;
}
</pre>
<p>Oman konstruktorin kutsu <code>this(nimi, 0);</code> saattaa vaikuttaa erikoiselta. Asiaa voi vaikka ajatella siten, että kutsun kohdalle tulee "copy-pastena" automaattisesti alemman konstruktorin koodi, siten että ika parametrin arvoksi tulee 0.</p>
<h3>Metodin kuormittaminen</h3>
<p>Konstruktorien tapaan myös metodeja voi kuormittaa, eli samannimisestä metodista voi olla useita versioita. Jälleen eri versioiden parametrien tyyppien on oltava erilaiset. Tehdään <code>vanhene</code>-metodista toinen versio, joka mahdollistaa henkilön vanhentamisen parametrina olevalla vuosimäärällä:</p>
<pre class="sh_java">
public void vanhene() {
    this.ika = this.ika + 1;
}

public void vanhene(int vuodet) {
    this.ika = this.ika + vuodet;
}
</pre>
<p>Seuraavassa "Pekka" syntyy 24-vuotiaana, vanhenee ensin vuoden ja sitten 10 vuotta:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );
    pekka.vanhene();
    System.out.println( pekka );
    pekka.vanhene(10);
    System.out.println( pekka );
}
</pre>
<p>Tulostuu:</p>
<pre>
Pekka, ikä 24 vuotta
Pekka, ikä 25 vuotta
Pekka, ikä 35 vuotta
</pre>
<p>Henkilöllä on siis <code>vanhene</code>-nimisiä metodeja 2 kappaletta. Se kumpi metodeista valitaan suoritettavaksi, riippuu metodikutsussa käytettyjen parametrien määrästä. Metodin <code>vanhene</code> voi myös toteuttaa metodin <code>vanhene(int vuodet)</code> avulla: </p>
<pre class="sh_java">
public void vanhene() {
    this.vanhene(1);
}

public void vanhene(int vuodet) {
    this.ika = this.ika + vuodet;
}
</pre>

<!-- CAST1--> 

<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=b6YmqoQopvs" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> 

<div class="tehtavat" id="viikko5">
  <div class="tehtava">
  <h3>Kuormitettu laskuri</h3>
  <h4>Monta konstruktoria</h4>
  <p>Toteuta luokka <code>Laskuri</code>, joka sisältää luvun, jota voi
    vähentää ja suurentaa. Laskurissa on lisäksi
    valinnainen <em>tarkistus</em> joka estää laskurin menemisen
    miinukselle. Luokalla tulee olla seuraavat konstruktorit:</p>
  <ul>
<li>
<code>public Laskuri(int alkuarvo, boolean tarkistus)</code> asettaa laskurin alkuarvoksi parametrin <code>alkuarvo</code> arvon.  Tarkistus on päällä jos  parametrin <code>tarkista</code> arvoksi annettiin <code>true</code>.</li>
    <li>
<code>public Laskuri(int alkuarvo)</code> asettaa laskurin alkuarvoksi parametrin <code>alkuarvo</code> arvon, tarkastus ei ole päällä.</li>
    <li>
<code>public Laskuri(boolean tarkista)</code> laskurin alkuarvoksi tulee 0.  Tarkistus on päällä jos  parametrin <code>tarkista</code> arvoksi annettiin <code>true</code>.</li>
    <li>
<code>public Laskuri()</code> laskurin alkuarvoksi tulee 0 ja tarkastus ei ole päällä.</li>
  </ul>
<p>ja seuraavat metodit:</p>
  <ul>
<li>
<code>public int arvo()</code> palauttaa laskurin tämänhetkisen arvon</li>
    <li>
<code>public void lisaa()</code> lisää laskurin arvoa yhdellä</li>
    <li>
<code>public void vahenna()</code> vähentää laskurin arvoa yhdellä,
      mutta ei alle nollan jos tarkistus on päällä</li>
  </ul>
<h4>Vaihtoehtoiset metodit</h4>
  <p>Tee laskurin metodeista <code>lisaa</code> ja <code>vahenna</code> myös yksiparametriset versiot:</p>
  <ul>
<li>
<code>public void lisaa(int lisays)</code> lisää laskurin arvoa parametrina annetun luvun verran. Jos parametrin arvo on negatiivinen, ei laskurin arvo muutu.</li>
    <li>
<code>public void vahenna(int vahennys)</code> vähentää laskurin arvoa parametrina annetun luvun verran,
      mutta ei alle nollan jos tarkistus on päällä. Jos parametrin arvo on negatiivinen, ei laskurin arvo muutu.</li>
  </ul>
</div>
</div>
<h3>Olio on langan päässä</h3>
<p>Luvussa 20 mainittiin, että <code>ArrayList</code> on "langan päässä". Myös oliot ovat langan päässä. Mitä tämä oikein tarkoittaa? Tarkastellaan seuraavaa esimerkkiä:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );
}
</pre>
<p>Kun suoritamme lauseen <code>Henkilo pekka = new Henkilo("Pekka", 24);</code> syntyy olio. Olioon päästään käsiksi muuttujan <code>pekka</code> avulla. Teknisesti ottaen olio ei ole muuttujan <code>pekka</code> "sisällä" (eli lokerossa pekka) vaan <code>pekka</code> viittaa syntyneeseen olioon. Toisin sanonen olio on <code>pekka</code>-nimisestä muuttujasta lähtevän "langan päässä". Kuvana asiaa voisi havainnollistaa seuraavasti: </p>
<p> <img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/lanka1.PNG"></p>
<p>Lisätään ohjelmaan <code>Henkilo</code>-tyyppinen muuttuja <code>henkilo</code> ja annetaan sille alkuarvoksi <code>pekka</code>. Mitä nyt tapahtuu?</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );

    Henkilo henkilo = pekka;
    henkilo.vanhene(25);

    System.out.println( pekka );
}
</pre>
<p>Tulostuu:</p>
<pre>
Pekka, ikä 24 vuotta
Pekka, ikä 49 vuotta
</pre>
<p>Eli Pekka on alussa 24-vuotias, <code>henkilo</code>-muuttujaan liittyvän langan päässä olevaa Henkilö-oliota vanhennetaan 25:llä vuodella ja sen seurauksena Pekka vanhenee! Mistä on kysymys? </p>
<p>Komento <code>Henkilo henkilo = pekka;</code> saa aikaan sen, että <code>henkilo</code> rupeaa viittaamaan samaan olioon kuin mihin <code>pekka</code> viittaa. Eli ei synnykään kopiota oliosta, vaan molemmissa muuttujissa on langan päässä sama olio. Komennossa <code>Henkilo henkilo = pekka;</code> syntyy <em>kopio langasta</em>. Kuvana (Huom: kuvassa p ja h tarkottavat pääohjelman muuttujia pekka ja henkilo. Kuvien muuttujanimiä on lyhennelty myös muutamassa seuraavassa kuvassa.):</p>
<p> <img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/lanka2.PNG"></p>
<p>Esimerkissä "vieras henkilö <code>henkilo</code> ryöstää Pekan identiteetin". Seuraavassa esimerkkiä on jatkettu siten, että luodaan uusi olio ja <code>pekka</code> alkaa viittaamaan uuteen olioon:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );

    Henkilo henkilo = pekka;
    henkilo.vanhene(25);

    System.out.println( pekka );

    pekka = new Henkilo("Pekka Mikkola", 24);
    System.out.println( pekka );
}
</pre>
<p>Tulostuu:</p>
<pre>
Pekka, ikä 24 vuotta
Pekka, ikä 49 vuotta
Pekka Mikkola, ikä 24 vuotta
</pre>
<p>Muuttuja <code>pekka</code> viittaa siis ensin yhteen olioon, mutta rupeaa sitten viittaamaan toiseen olion. 
  
  Seuraavassa kuva tilanteesta viimeisen koodirivin jälkeen:</p>
<p> <img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/lanka3.PNG"></p>
<p>Jatketaan vielä esimerkkiä laittamalla <code>henkilo</code> viittaamaan "ei mihinkään", eli <code>null</code>:iin: </p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );

    Henkilo henkilo = pekka;
    henkilo.vanhene(25);

    System.out.println( pekka );

    pekka = new Henkilo("Pekka Mikkola", 24);
    System.out.println( pekka );

    henkilo = null;
    System.out.println( henkilo );
}
</pre>
<p>Viimeisen koodirivin jälkeen näyttää seuraavalta:</p>
<p> <img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/lanka4.PNG"></p>
<p>Alempaan olioon ei nyt viittaa kukaan. Oliosta on tullut "roska". Javan roskienkerääjä käy siivoamassa aika ajoin roskaksi joutuneet oliot. Jos näin ei tehtäisi, jäisivät ne kuluttamaan turhaan koneen muistia ohjelman suorituksen loppuun asti.</p>
<p>Huomaamme, että viimeisellä rivillä yritetään vielä tulostaa "ei mitään" eli <code>null</code>. Käy seuraavasti:</p>
<pre>
Pekka, ikä 24 vuotta
Pekka, ikä 49 vuotta
Pekka Mikkola, ikä 24 vuotta
null
</pre>
<p>Mitä tapahtuu jos yritämme kutsua "ei minkään" metodia, esimerkiksi metodia <code>painoIndeksi</code>:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );

    Henkilo henkilo = null;
    System.out.println( henkilo.painoIndeksi() );
}
</pre>
<p>Tulos:</p>
<pre>
Pekka, ikä 24 vuotta
<font color="red">Exception in thread "main" java.lang.NullPointerException
at Main.main(Main.java:20)
Java Result: 1</font>
</pre>
<p>Eli käy huonosti. Tämän on ehkä ensimmäinen kerta elämässäsi kun näet tekstin <b>NullPointerException</b>. Voimme luvata, että tulet näkemään sen vielä uudelleen. NullPointerException on poikkeustila, joka syntyy kun <code>null</code>-arvoisen olion metodeja yritetään kutsua.</p>
<h3>Metodin parametrina olio</h3>
<p>Olemme nähneet että metodien parametrina voi olla esim. <code>int, double, String</code> tai ArrayList. ArrayListit ja merkkijonot ovat olioita, joten kuten arvata saattaa, metodi voi saada 
  parametriksi minkä tahansa tyyppisen olion. Demonstroidaan tätä esimerkillä.</p>
<p>Painonvartijoihin hyväksytään jäseniksi henkilöitä, joiden painoindeksi ylittää jonkun annetun rajan. 
  Kaikissa painonvartijayhdistyksissä raja ei ole sama. Tehdään painonvartijayhdistystä vastaava luokka. 
  Olioa luotaessa konstruktorille annetaan parametriksi pienin painoindeksi, jolla yhdistyksen jäseneksi pääsee. </p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
    private double alinPainoindeksi;

    public PainonvartijaYhdistys(double indeksiRaja) {
        this.alinPainoindeksi = indeksiRaja;
    }

}
</pre>
<p>Tehdään sitten metodi, jonka avulla voidaan tarkastaa hyväksytäänkö tietty henkilö 
  yhdistyksen jäseneksi, eli onko henkilön painoindeksi tarpeeksi suuri. 
  Metodi palauttaa <code>true</code> jos parametrina annettu henkilö hyväksytään, <code>false</code> jos ei.</p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
    // ...

    public boolean hyvaksytaanJaseneksi(Henkilo henkilo) {
        if ( henkilo.painoIndeksi() &lt; this.alinPainoindeksi ) {
            return false;
        }
        return true;
        }
}
</pre>
<p>Painonvartijayhdistys-olion metodi <code>hyvaksytaanJaseneksi</code> saa siis parametriksi <code>Henkilo</code>-olion (tarkemmin sanottuna "langan" henkilöön) ja kutsuu parametrina saamansa henkilön metodia <code>painoIndeksi</code>. </p>
<p>Seuraavassa testipääohjelma jossa painonvartijayhdistyksen metodille annetaan ensin parametriksi henkilöolio <code>matti</code> ja sen jälkeen henkilöolio <code>juhana</code>:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo matti = new Henkilo("Matti");
    matti.setPaino(86);
    matti.setPituus(180);

    Henkilo juhana = new Henkilo("Juhana");
    juhana.setPaino(64);
    juhana.setPituus(172);

    PainonvartijaYhdistys kumpulanPaino = new PainonvartijaYhdistys(25);

    if ( kumpulanPaino.hyvaksytaanJaseneksi(matti) ) {
        System.out.println( matti.getNimi() + " pääsee jäseneksi");
    } else {
        System.out.println( matti.getNimi() + " ei pääse jäseneksi");
    }

    if ( kumpulanPaino.hyvaksytaanJaseneksi(juhana) ) {
        System.out.println( juhana.getNimi() + " pääsee jäseneksi");
    } else {
        System.out.println( juhana.getNimi() + " ei pääse jäseneksi");
    }
}
</pre>
<p> Ohjelma tulostaa: </p>
<pre>
Matti pääsee jäseneksi
Juhana ei pääse jäseneksi
</pre>
<div> <p><big><b>Muutama NetBeans-vihje</b></big></p>
  <ul>
<li> Kaikki NetBeans-vihjeet löytyvät <a href="netbeans.html">täältä</a> </li>
    <li> <b>Konstruktorien, getterien ja setterien automaattinen generointi</b>
      <p> Mene luokan koodilohkon sisäpuolelle mutta kaikkien metodien ulkopuolelle ja paina yhtä aikaa ctrl ja välilyönti. Jos luokallasi on esim. oliomuuttuja <code>saldo</code>, tarjoaa NetBeans mahdollisuuden generoida oliomuuttujalle getteri- ja setterimetodit sekä konstruktorin joka asettaa oliomuuttujalle alkuarvon. <b>HUOM:</b> laitoksen tämä saadaan aikaan painamalla yhtä aikaa ctrl, alt ja välilyönti. </p>
    </li>
  </ul>
</div>

<!-- CAST2 --> 

<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=aSFT6UnyvE0" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> 


<div class="tehtavat">
  <div class="tehtava">
  <h3>Kasvatuslaitos</h3>
  <p>Tehtäväpohjassasi on valmiina jo tutuksi tullut luokka <code>Henkilo</code> sekä runko luokalle <code>Kasvatuslaitos</code>. Kasvatuslaitosoliot käsittelevät ihmisiä eri tavalla, esim. punnitsevat ja syöttävät ihmisiä. Rakennamme tässä tehtävässä kasvatuslaitoksen. Luokan Henkilö koodiin ei tehtävässä ole tarkoitus koskea!</p>
  <h4>Henkilöiden punnitseminen</h4>
  <p>Kasvatuslaitoksen luokkarungossa on valmiina runko metodille <code>punnitse</code>:</p>
  <pre class="sh_java">
public class Kasvatuslaitos {

    public int punnitse(Henkilo henkilo) {
        // palautetaan parametrina annetun henkilön paino
        return -1;
    }
}
</pre>
  <p>Metodi saa parametrina henkilön ja metodin on tarkoitus palauttaa kutsujalleen parametrina olevan henkilön paino. Paino selviää kutsumalla parametrina olevan henkilön <code>henkilo</code> sopivaa metodia. <strong>Eli täydennä metodin koodi!</strong></p>
  <p>Seuraavassa on pääohjelma jossa kasvatuslaitos punnitsee kaksi henkilöä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    // esimerkkipääohjelma tehtävän ensimmäiseen kohtaan

    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");
}
</pre>
  <p>Tulostuksen pitäisi olla seuraava:</p>
<pre>
Eero paino: 7 kiloa
Pekka paino: 85 kiloa
</pre>
  <h4>syötä</h4>
  <p>Parametrina olevan olion tilaa on mahdollista muuttaa. Tee kasvatuslaitokselle metodi <code>public void syota(Henkilo henkilo)</code> joka kasvattaa parametrina olevan henkilön painoa yhdellä. </p>
  <p>Seuraavassa esimerkki, jossa henkilöt ensin punnitaan, ja tämän jälkeen neuvolassa syötetään eeroa kolme kertaa. Tämän jälkeen henkilöt taas punnitaan:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");

    haaganNeuvola.syota(eero);
    haaganNeuvola.syota(eero);
    haaganNeuvola.syota(eero);

    System.out.println("");

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");
}
</pre>
  <p>Tulostuksen pitäisi paljastaa että Eeron paino on noussut kolmella:</p>
<pre>
Eero paino: 7 kiloa
Pekka paino: 85 kiloa

Eero paino: 10 kiloa
Pekka paino: 85 kiloa
</pre>
  <h4>laske punnitukset</h4>
  <p>Tee kasvatuslaitokselle metodi <code>public int
    punnitukset()</code> joka kertoo kuinka monta punnitusta
    kasvatuslaitos on ylipäätään tehnyt. Testipääohjelma:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    // esimerkkipääohjelma tehtävän ensimmäiseen kohtaan

    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println("punnituksia tehty "+haaganNeuvola.punnitukset());

    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(pekka);

    System.out.println("punnituksia tehty "+haaganNeuvola.punnitukset());

    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);

    System.out.println("punnituksia tehty "+haaganNeuvola.punnitukset());
}
</pre>
  <p>Tulostuu:</p>
<pre>
punnituksia tehty 0
punnituksia tehty 2
punnituksia tehty 6
</pre>
</div>
<div class="tehtava">
  <h3>Lyyra-kortti ja Kassapääte</h3>
  <h4 class="req">"Tyhmä" Lyyra-kortti</h4>
  <p>Teimme viime viikolla luokan LyyraKortti. Kortilla oli metodit edullisesti ja maukkaasti syömistä sekä rahan lataamista varten.</p>
  <p>Viime viikon tyylillä tehdyssä Lyyra-kortissa oli kuitenkin ongelma. Kortti tiesi lounaiden hinnan ja osasi sen ansiosta vähentää saldoa oikean määrän. Entä kun hinnat nousevat? Tai jos myyntivalikoimaan tulee uusia tuotteita? Hintojen muuttaminen tarkoittaisi, että kaikki jo käytössä olevat Lyyra-kortit pitäisi korvata uusilla, uudet hinnat tuntevilla korteilla. </p>
  <p>Parempi ratkaisu on tehdä kortit "tyhmiksi", hinnoista ja myytävistä tuotteista tietämättömiksi pelkän saldon säilyttäjiksi. Kaikki äly kannattaakin laittaa erillisiin olioihin, kassapäätteisiin.</p>
  <p>Toteutetaan ensin Lyyra-kortista "tyhmä" versio. Kortilla on ainoastaan metodit saldon kysymiseen, rahan lataamiseen ja rahan ottamiseen. Täydennä alla (ja tehtäväpohjassa) olevaan luokkaan metodin <code>public boolean otaRahaa(double maara)</code> ohjeen mukaan:</p>
  <pre class="sh_java">
public class LyyraKortti {
    private double saldo;

    public LyyraKortti(double saldo) {
      this.saldo = saldo;
    }

    public double saldo() {
        return this.saldo;
    }

    public void lataaRahaa(double lisays) {
        this.saldo += lisays;
    }

    public boolean otaRahaa(double maara){
        // toteuta metodi siten että se ottaa kortilta rahaa vain jos saldo on vähintään maara
        // onnistuessaan metodi palauttaa true ja muuten false
    }
}
</pre>
  <p>Testipääohjelma:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti pekanKortti = new LyyraKortti(10);

        System.out.println("rahaa " + pekanKortti.saldo() );
        boolean onnistuiko = pekanKortti.otaRahaa(8);
        System.out.println("onnistuiko otto: " + onnistuiko );
        System.out.println("rahaa " + pekanKortti.saldo() );

        onnistuiko = pekanKortti.otaRahaa(4);
        System.out.println("onnistuiko otto: " + onnistuiko );
        System.out.println("rahaa " + pekanKortti.saldo() );
      }
}
</pre>
  <p>Tulostuksen kuuluisi olla seuraavanlainen</p>
<pre>
rahaa 10.0
onnistuiko otto: true
rahaa 2.0
onnistuiko otto: false
rahaa 2.0
</pre>
  <h4 class="req">Kassapääte ja käteiskauppa</h4>
  <p>Unicafessa asioidessa asiakas maksaa joko käteisellä tai Lyyra-kortilla. Myyjä käyttää kassapäätettä kortin velottamiseen ja käteismaksujen hoitamiseen. Tehdään ensin kassapäätteestä käteismaksuihin sopiva versio. </p>
  <p>Kassapäätteen runko. Metodien kommentit kertovat halutun toiminnallisuuden:</p>
  <pre class="sh_java">
public class Kassapaate {
    private double rahaa;  // kassassa olevan käteisen määrä
    private int edulliset; // myytyjen edullisten lounaiden määrä
    private int maukkaat;  // myytyjen maukkaiden lounaiden määrä

    public Kassapaate() {
        // kassassa on aluksi 1000 euroa rahaa
    }

    public double syoEdullisesti(double maksu) {
        // edullinen lounas maksaa 2.50 euroa. 
        // kasvatetaan kassan rahamäärää edullisenlounaan hinnalla ja palautetaan vaihtorahat
        // jos parametrina annettu maksu ei ole riittävän suuri, ei lounasta myydä ja metodi palauttaa koko summan
    }

    public double syoMaukkaasti(double maksu) {
        // maukas lounas maksaa 4.00 euroa. 
        // kasvatetaan kassan rahamäärää maukkaan lounaan hinnalla ja palautetaan vaihtorahat
        // jos parametrina annettu maksu ei ole riittävän suuri, ei lounasta myydä ja metodi palauttaa koko summan
    }

    public String toString() { 
        return "kassassa rahaa "+rahaa+" edullisia lounaita myyty "+edulliset+" maukkaita lounaita myyty "+maukkaat;
    }
}
</pre>
  <p>Kassapäätteessä on aluksi rahaa 1000 euroa. Toteuta ylläolevan rungon metodit ohjeen ja alla olevan pääohjelman esimerkkitulosteen mukaan toimiviksi. </p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Kassapaate unicafeExactum = new Kassapaate();

        double vaihtorahaa = unicafeExactum.syoEdullisesti(10);
        System.out.println("vaihtorahaa jäi " + vaihtorahaa );

        vaihtorahaa = unicafeExactum.syoEdullisesti(5);
        System.out.println("vaihtorahaa jäi "  + vaihtorahaa );

        vaihtorahaa = unicafeExactum.syoMaukkaasti(4);
        System.out.println("vaihtorahaa jäi "  + vaihtorahaa );

        System.out.println( unicafeExactum );
    }
}
</pre>
  <pre>
vaihtorahaa jäi 7.5
vaihtorahaa jäi 2.5
vaihtorahaa jäi 0.0
kassassa rahaa 1009.0 edullisia lounaita myyty 2 maukkaita lounaita myyty 1
</pre>
  <h4 class="req">Kortilla maksaminen</h4>
  <p>Laajennetaan kassapäätettä siten että myös kortilla voi maksaa. Teemme kassapäätteelle siis metodit joiden parametrina kassapääte saa lyyrakortin jolta se vähentää valitun lounaan hinnan.
    Seuraavassa uusien metodien rungot ja ohje niiden toteuttamiseksi:</p>
<pre class="sh_java">
public class Kassapaate {    
    // ...

    public boolean syoEdullisesti(LyyraKortti kortti) {
        // edullinen lounas maksaa 2.50 euroa. 
        // jos kortilla on tarpeeksi rahaa, vähennetään hinta kortilta ja palautetaan true
        // muuten palautetaan false
    }

    public boolean syoMaukkaasti(LyyraKortti kortti) {
        // edullinen lounas maksaa 4.00 euroa.
        // jos kortilla on tarpeeksi rahaa, vähennetään hinta kortilta ja palautetaan true
        // muuten palautetaan false
    }

    // ...
}
</pre>
  <p><b>Huom:</b> kortilla maksaminen ei lisää kassapäätteessä olevan käteisen määrää.</p>
  <p>Seuraavassa testipääohjelma ja haluttu tulostus:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Kassapaate unicafeExactum = new Kassapaate();

        double vaihtorahaa = unicafeExactum.syoEdullisesti(10);
        System.out.println("vaihtorahaa jäi " + vaihtorahaa );

        LyyraKortti antinKortti = new LyyraKortti(7);      

        boolean onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);
        onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);
        onnistuiko = unicafeExactum.syoEdullisesti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);

        System.out.println( unicafeExactum );
    }
}
</pre>
<pre>
vaihtorahaa jäi 7.5
riittikö raha: true
riittikö raha: false
riittikö raha: true
kassassa rahaa 1002.5 edullisia lounaita myyty 2 maukkaita lounaita myyty 1
</pre>
  <h4 class="req">Rahan lataaminen</h4>
  <p>Lisätään vielä kassapäätteelle metodi jonka avulla kortille voidaan ladata lisää rahaa. Muista, että rahan lataamisen yhteydessä ladattava summa viedään kassapäätteeseen. Metodin runko:</p>
  <pre class="sh_java">
public void lataaRahaaKortille(LyyraKortti kortti, double summa) {
    // ...
}
</pre>
  <p>Testipääohjelma ja esimerkkisyöte:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Kassapaate unicafeExactum = new Kassapaate();
        System.out.println( unicafeExactum );

        LyyraKortti antinKortti = new LyyraKortti(2);

        System.out.println("kortilla rahaa " + antinKortti.saldo() + " euroa");

        boolean onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);

        unicafeExactum.lataaRahaaKortille(antinKortti, 100);

        onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);

        System.out.println("kortilla rahaa " + antinKortti.saldo() + " euroa");

        System.out.println( unicafeExactum );
    }
}
</pre>
<pre>
kassassa rahaa 1000.0 edullisia lounaita myyty 0 maukkaita lounaita myyty 0
kortilla rahaa 2.0 euroa
riittikö raha: false
riittikö raha: true
kortilla rahaa 98.0 euroa
kassassa rahaa 1100.0 edullisia lounaita myyty 0 maukkaita lounaita myyty 1
</pre>
</div>
</div>
<h3>Metodin parametrina toinen samantyyppinen olio</h3>
<p>Jatkamme edelleen luokan <code>Henkilo</code> parissa. Kuten muistamme, henkilöt tietävät ikänsä:</p>
<pre class="sh_java">
public class Henkilo {

    private String nimi;
    private int ika;
    private int pituus;
    private int paino;

    // ...
}
</pre>
<p>Haluamme vertailla kahden henkilön ikää. Vertailu voidaan hoitaa usealla tavalla. Henkilölle voitaisiin määritellä getterimetodi <code>getIka</code> ja kahden henkilön iän vertailu tapauhtuisi tällöin seuraavasti:</p>
<pre class="sh_java">
Henkilo pekka = new Henkilo("Pekka");
Henkilo juhana = new Henkilo("Juhana") 

if ( pekka.getIka() &gt; juhana.getIka() ) {
    System.out.println( pekka.getNimi() + " on vanhempi kuin " + juhana.getNimi() );
}
</pre>
<p>Opettelemme kuitenkin nyt hieman "oliohenkisemmän" tavan kahden henkilön ikävertailun tekemiseen.</p>
<p>Teemme Henkilö-luokalle metodin <code>boolean vanhempiKuin(Henkilo verrattava)</code> jonka avulla tiettyä henkilö-olioa voi verrata parametrina annettuun henkilöön iän perusteella. </p>
<p>Metodia on tarkoitus käyttää seuraavaan tyyliin:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);
    Henkilo antti = new Henkilo("Antti", 22);

    if ( pekka.vanhempiKuin(antti) ) {  //  sama kun pekka.vanhempiKuin(antti)==true
        System.out.println( pekka.getNimi() + " on vanhempi kuin " + antti.getNimi() );
    } else {
        System.out.println( pekka.getNimi() + " ei ole vanhempi kuin " + antti.getNimi() );
    }
}
</pre>
<p>Tässä siis kysytään Pekalta onko hän Anttia vanhempi, Pekka vastaa true jos on ja false muuten. Käytännössä kutsutaan "Pekkaa" vastaavan olion johon <code>pekka</code> viittaa metodia <code>vanhempiKuin</code>, jolle annetaan parametriksi "Anttia" vastaavan olion viite <code>antti</code>. </p>
<p>Ohjelman tulostaa:</p>
<pre>
Pekka on vanhempi kuin Antti
</pre>
<p>Metodi saa parametrikseen henkilöolion (tarkemmin sanottuna viitteen henkilöolioon, eli "langan päässä" olevan henkilön) ja vertaa omaa ikäänsä <code>this.ika</code> verrattavaksi annetun henkilön ikään <code>verrattava.ika</code>. Toteutus näyttää seuraavalta:</p>
<pre class="sh_java">
public class Henkilo {
    // ... 

    public boolean vanhempiKuin(Henkilo verrattava) {
        if ( this.ika &gt; verrattava.ika ) {
            return true;
        }

        return false;
      }
}
</pre>
<p>Vaikka <code>ika</code> onkin olion yksityinen (<code>private</code>) oliomuuttuja, 
  pystymme lukemaan muuttujan arvon kirjoittamalla <code>verrattava.ika</code>.
  Tämä johtuu siitä, että <code>private</code>-muuttujat ovat luettavissa kaikissa
  metodeissa, jotka kyseinen luokka sisältää. Huomaa, että syntaksi (kirjoitusasu) vastaa
  tässä jonkin olion metodin kutsumista. Toisin kuin metodia kutsuttaessa, viittaamme olion kenttään,
  jolloin metodikutsun osoittavia sulkeita ei kirjoiteta. </p>
<h3>Päiväys oliona</h3>
<p>Toinen esimerkki samasta teemasta. Tehdään luokka, jonka avulla voidaan esittää päiväyksiä.</p>
<p>Olion sisällä päiväys esitetään kolmella oliomuuttujalla. Tehdään myös metodi jolla voi vertailla onko päivämäärä aiemmin kuin parametrina annettu päivämäärä:</p>
<pre class="sh_java">
public class Paivays {
    private int paiva;
    private int kuukausi;
    private int vuosi;

    public Paivays(int paiva, int kuukausi, int vuosi) {
        this.paiva = paiva;
        this.kuukausi = kuukausi;
        this.vuosi = vuosi;
    }

    public String toString() {
        return this.paiva + "." + this.kuukausi + "." + this.vuosi;
    }

    public boolean aiemmin(Paivays verrattava) {
        // ensin verrataan vuosia
        if ( this.vuosi &lt; verrattava.vuosi ) {
            return true;
        }

        // jos vuodet ovat samat, verrataan kuukausia
        if ( this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi &lt; verrattava.kuukausi ) {
            return true;
        }

        // vuodet ja kuukaudet samoja, verrataan päivää
        if ( this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi == verrattava.kuukausi &amp;&amp;
            this.paiva &lt; verrattava.paiva ) {
            return true;
        }

        return false;
    }
}
</pre>
<p>Käyttöesimerkki:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Paivays p1 = new Paivays(14, 2, 2011);
    Paivays p2 = new Paivays(21, 2, 2011);
    Paivays p3 = new Paivays(1, 3, 2011);
    Paivays p4 = new Paivays(31, 12, 2010);

    System.out.println( p1 + " aiemmin kuin " + p2 + ": " + p1.aiemmin(p2));
    System.out.println( p2 + " aiemmin kuin " + p1 + ": " + p2.aiemmin(p1));

    System.out.println( p2 + " aiemmin kuin " + p3 + ": " + p2.aiemmin(p3));
    System.out.println( p3 + " aiemmin kuin " + p2 + ": " + p3.aiemmin(p2));

    System.out.println( p4 + " aiemmin kuin " + p1 + ": " + p4.aiemmin(p1));
    System.out.println( p1 + " aiemmin kuin " + p4 + ": " + p1.aiemmin(p4));
}
</pre>
<pre>
14.2.2011 aiemmin kuin 21.2.2011: true
21.2.2011 aiemmin kuin 14.2.2011: false
21.2.2011 aiemmin kuin 1.3.2011: true
1.3.2011 aiemmin kuin 21.2.2011: false
31.12.2010 aiemmin kuin 14.2.2011: true
14.2.2011 aiemmin kuin 31.12.2010: false
</pre>

<!-- CAST3 --> 

<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=9XYbf5V7uGs" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> 

<div class="tehtavat">
  <div class="tehtava">
  <h3>Asuntovertailu</h3>
  <p>Asuntovälitystoimiston tietojärjestelmässä myynnissä olevaa asuntoa kuvataan seuraavan luokan olioilla:</p>
  <pre class="sh_java">
public class Asunto {
    private int huoneita;
    private int nelioita;
    private int neliohinta;

    public Asunto(int huoneita, int nelioita, int neliohinta){
        this.huoneita = huoneita;
        this.nelioita = nelioita;
        this.neliohinta = neliohinta;
    }
}
</pre>
  <p>Tehtävänä on toteuttaa muutama metodi, joiden avulla myynnissä olevia asuntoja voidaan vertailla.</p>
  <h4>Suurempi</h4>
  <p>Tee metodi <code>public boolean suurempi(Asunto verrattava)</code> joka palauttaa true jos asunto-olio, jolle metodia kutsutaan on suurempi kuin verrattavana oleva asunto-olio.</p>
  <p>Esimerkki metodin toiminnasta:</p>
  <pre class="sh_java">
Asunto eiraYksio = new Asunto(1, 16, 5500);
Asunto kallioKaksio = new Asunto(2, 38, 4200);
Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

System.out.println( eiraYksio.suurempi(kallioKaksio) );       // false
System.out.println( jakomakiKolmio.suurempi(kallioKaksio) );  // true
</pre>
  <h4>Hintaero</h4>
  <p>Tee metodi <code>public int hintaero(Asunto verrattava)</code> joka palauttaa asunto-olion jolle metodia kutsuttiin ja parametrina olevan asunto-olion hintaeron. Hintaero on asuntojen hintojen (=neliöhinta*neliöt) itseisarvo.</p>
  <p>Esimerkki metodin toiminnasta:</p>
<pre class="sh_java">
Asunto eiraYksio = new Asunto(1, 16, 5500);
Asunto kallioKaksio = new Asunto(2, 38, 4200);
Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

System.out.println( eiraYksio.hintaero(kallioKaksio) );        // 71600
System.out.println( jakomakiKolmio.hintaero(kallioKaksio) );   // 35400
</pre>
  <h4>Kalliimpi</h4>
  <p>Tee metodi <code>public boolean kalliimpi(Asunto verrattava)</code> joka palauttaa true jos asunto-olio, jolle metodia kutsutaan on kalliimpi kuin verrattavana oleva asunto-olio.</p>
  <p>Esimerkki metodin toiminnasta:</p>
  <pre class="sh_java">
Asunto eiraYksio = new Asunto(1, 16, 5500);
Asunto kallioKaksio = new Asunto(2, 38, 4200);
Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

System.out.println( eiraYksio.kalliimpi(kallioKaksio) );       // false
System.out.println( jakomakiKolmio.kalliimpi(kallioKaksio) );   // true
</pre>
</div>
</div>
<h3>Olioita listalla</h3>
<p>Olemme käyttäneet <code>ArrayList</code>:ejä jo monessa esimerkissä ja tehtävässä. ArrayList-olioon pystyy lisäämään esimerkiksi merkkijonoja ja listalla olevien merkkijonojen läpikäynti, etsiminen, poistaminen, järjestäminen ym. ovat vaivattomia toimenpiteitä.</p>
<p>ArrayList:eihin voidaan laittaa minkä tahansa tyyppisiä oliota. Luodaan seuraavassa henkilölista, eli tyyppiä <code>ArrayList&lt;Henkilo&gt;</code> oleva ArrayList ja laitetaan sinne muutama henkilöolio:</p>
<pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Henkilo&gt; opettajat = new ArrayList&lt;Henkilo&gt;();

    // voidaan ensin ottaa henkilö muuttujaan
    Henkilo opettaja = new Henkilo("Juhana");
    // ja lisätä se sitten listalle
    opettajat.add(opettaja);

    // tai voidaan myös luoda olio lisättäessä:
    opettajat.add( new Henkilo("Matti") );
    opettajat.add( new Henkilo("Martin") );

    System.out.println("opettajat vastasyntyneenä: ");
    for ( Henkilo hlo : opettajat ) {
        System.out.println( hlo );
    }

    for ( Henkilo hlo : opettajat ) {
        hlo.vanhene( 30 );
    }

    System.out.println("30 vuoden kuluttua: ");
    for ( Henkilo hlo : opettajat ) {
        System.out.println( hlo );
    }
}
</pre>
<p>Ohjelman tulostus:</p>
<pre>
opettajat vastasyntyneenä: 
Juhana, ikä 0 vuotta
Matti, ikä 0 vuotta
Martin, ikä 0 vuotta
30 vuoden kuluttua: 
Juhana, ikä 30 vuotta
Matti, ikä 30 vuotta
Martin, ikä 30 vuotta
</pre>
<div class="tehtavat">
  <div class="tehtava">
  <h3>Opiskelija-luokka</h3>
  <h4 class="req">Opiskelija-luokka</h4>
  <p>Tee luokka <code>Opiskelija</code>,
    johon tallennetaan seuraavat tiedot opiskelijasta:</p>
  <ul>
<li> nimi (<code>String</code>)</li>
    <li> opiskelijanumero (<code>String</code>)</li>
  </ul>
<p>Tee luokkaan seuraavat metodit:</p>
  <ul>
<li> konstruktori, jolle annetaan opiskelijan nimi ja opiskelijanumero</li>
    <li> <code>haeNimi</code>, joka palauttaa opiskelijan nimen, esim. Pekka Mikkola</li>
    <li> <code>haeOpiskelijanumero</code>, joka palauttaa opiskelijan opiskelijanumeron, esim. 013141590</li>
    <li> <code>toString</code>, joka palauttaa merkkijonoesityksen opiskelijasta muodossa: Pekka Mikkola (013141590)</li>
  </ul>
<p>Voit testata luokan toimintaa seuraavalla koodilla:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Opiskelija pekka = new Opiskelija("Pekka Mikkola", "013141590");
        System.out.println("Nimi: " + pekka.haeNimi());
        System.out.println("Opiskelijanumero: " + pekka.haeOpiskelijanumero());
        System.out.println(pekka);
    }
}
</pre>
  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>
  <pre>
Nimi: Pekka Mikkola
Opiskelijanumero: 013141590
Pekka Mikkola (013141590)
</pre>
  <h4 class="req">Opiskelijalista</h4>
  <p>Tee edellisen tilalle uusi pääohjelma, joka kysyy alla olevan esimerkkitulostuksen tyyliin opiskelijoiden tietoja (ensin kysytään nimi ja sen jälkeen opiskelijanumero). Ohjelma luo jokaisesta opiskelijasta uuden olion ja tallentaa sen listaan. Kun käyttäjä antaa nimeksi tyhjän merkkijonon, ohjelma tulostaa listalla olevat opiskelijat.</p>
  <p>Listan määrittelyn tulisi olla seuraava:</p>
  <pre class="sh_java">
  ArrayList&lt;Opiskelija&gt; lista = new ArrayList&lt;Opiskelija&gt;();
</pre>
  <p>Seuraavassa on esimerkki ohjelman suorituksesta:</p>
  <pre>
Nimi: <font color="red">Alfred Apina</font>
Opiskelijanumero: <font color="red">017635727</font>
Nimi: <font color="red">Bruno Banaani</font>
Opiskelijanumero: <font color="red">011288989</font>
Nimi: <font color="red">Cecilia Cembalo</font>
Opiskelijanumero: <font color="red">013672548</font>
Nimi: 

Alfred Apina (017635727)
Bruno Banaani (011288989)
Cecilia Cembalo (013672548)
</pre>
  <h4 class="req">Opiskelijahaku</h4>
  <p>Laajenna edellisen tehtävän opiskelijalistaa siten,
    että listan syöttämisen jälkeen pääohjelma kysyy hakusanan,
    jonka avulla voi hakea opiskelijat,
    joiden nimessä on annettu hakusana.
    Tehtävänäsi on siis toteuttaa hakutoiminto.</p>
  <p>Vihje: Käy opiskelijat läpi silmukassa ja
    tarkista <code>String</code>-luokan <code>contains</code>-metodilla,
    onko hakusana opiskelijan nimessä.</p>
  <p>Seuraavassa on esimerkki ohjelman suorituksesta:</p>
  <pre>
Nimi: <font color="red">Saku Silmukka</font>
Opiskelijanumero: <font color="red">015696234</font>
Nimi: <font color="red">Cecilia Cembalo</font>
Opiskelijanumero: <font color="red">013672548</font>
Nimi: <font color="red">Taina Taulukko</font>
Opiskelijanumero: <font color="red">014662803</font>
Nimi: 

Saku Silmukka (015696234)
Cecilia Cembalo (013672548)
Taina Taulukko (014662803)

Anna hakusana: <font color="red">ukk</font>
Tulokset:
Saku Silmukka (015696234)
Taina Taulukko (014662803)
</pre>
</div>
</div>
<h3>Olion sisällä olio</h3>
<p>Olioiden sisällä voi olla olioita, ei pelkästään merkkijonoja vaan myös itse määriteltyjä oliota. Jatketaan taas <code>Henkilo</code>-luokan parissa ja lisätään henkilölle syntymäpäivä. Syntymäpäivä on luonnollista esittää aiemmin tehdyn <code>Paivays</code>-olion avulla:</p>
<pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;
    private int paino;
    private int pituus;
    private Paivays syntymaPaiva;

    // ...
  </pre>
<p>Tehdään henkilölle uusi konstruktori, joka mahdollistaa syntymäpäivän asettamisen:</p>
<pre class="sh_java">
public Henkilo(String nimi, int paiva, int kuukausi, int vuosi) {
    this.nimi = nimi;
    this.paino = 0;
    this.pituus = 0;
    this.syntymaPaiva = new Paivays(paiva, kuukausi, vuosi);
}
</pre>
<p>Eli konstruktorin parametrina annetaan erikseen päiväyksen osat (päivä, kuukausi, vuosi), niistä 
  luodaan päiväysolio joka <i>sijoitetaan</i> oliomuuttujaan <code>syntymaPaiva</code>.</p>
<p>Muokataan <code>toString</code> siten, että iän sijaan se näyttää syntymäpäivän:</p>
<pre class="sh_java">
public String toString() {
    return this.nimi + ", syntynyt " + this.syntymaPaiva;
}
</pre>
<p>Ja kokeillaan miten uusittu Henkilö-luokka toimii:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo martin = new Henkilo("Martin", 24, 4, 1983);

    Henkilo juhana = new Henkilo("Juhana", 17, 9, 1985);

    System.out.println( martin );
    System.out.println( juhana );
  }
</pre>
<p>Tulostuu:</p>
<pre>
Martin, syntynyt 24.4.1983
Juhana, syntynyt 17.9.1985
</pre>
<p>Luvussa 24.4 todettiin, että oliot ovat "langan päässä". Kertaa nyt luku 24.4.</p>
<p>Henkilö-oliolla on oliomuuttujat <code>nimi</code> joka on merkkijono-olio ja <code>syntymaPaiva</code> joka on Päiväys-olio. Henkilön oliomuuttujat siis ovat molemmat olioita, eli teknisesti ottaen ne eivät sijaitse henkilö-olion sisällä vaan ovat "langan päässä", ts. henkilöllä on oliomuuttujissa tallessa viite niihin. Kuvana:</p>
<p> <img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/henkilo.PNG"></p>
<p>Pääohjelmalla on nyt siis langan päässä kaksi Henkilö-olioa. Henkilöllä on nimi ja syntymäpäivä. Koska molemmat ovat olioita, ovat ne henkilöllä langan päässä.</p>
<p>Syntymäpäivä vaikuttaa hyvältä laajennukselta Henkilö-luokkaan. Huomaamme kuitenkin, että oliomuuttuja <code>ikä</code> uhkaa jäädä turhaksi ja lienee syytä poistaa se. Iän pystyy nimittäin tarvittaessa selvittämään helposti nykyisen päivämäärän ja syntymäpäivän perusteella. Javassa nykyinen päivä selviää esim. seuraavasti:</p>
<pre class="sh_java">
int paiva = Calendar.getInstance().get(Calendar.DATE);
int kuukausi = Calendar.getInstance().get(Calendar.MONTH) + 1; // tammikuun numero 0 joten  lisätään 1
int vuosi = Calendar.getInstance().get(Calendar.YEAR);
System.out.println("tänään on " + paiva + "." + kuukausi + "." + vuosi );
</pre>
<p>Kun ikä poistetaan, täytyy <code>vanhempiKuin</code>-metodi muuttaa toimimaan syntymäpäiviä 
  vertaamalla. Teemme muutoksen harjoitustehtävänä.</p>
<div class="tehtavat">
  <div class="tehtava">
    <h3>Kellosta olio</h3>
  <p>Edellisen viikon tehtävässä 78 tehtiin ensin luokka <code>YlhaaltaRajoitettuLaskuri</code> ja rakennettiin laskurien avulla pääohjelmaan kello. Tehdään nyt myös itse kellosta olio. Luokan kello runko näyttää seuraavalta:</p>
  <pre class="sh_java">

public class Kello {
    private YlhaaltaRajoitettuLaskuri tunnit;
    private YlhaaltaRajoitettuLaskuri minuutit;
    private YlhaaltaRajoitettuLaskuri sekunnit;

    public Kello(int tunnitAlussa, int minuutitAlussa, int sekunnitAlussa) {
      // luodaan kello joka asetetaan parametrina annettuun aikaan
    }

    public void etene(){
      // kello etenee sekunnilla
    }

    public String toString() {
        // palauttaa kellon merkkijonoesityksen
      }
}
</pre>
  <p>Kopioi uuteen projektiin viime viikon tehtävän 78 <code>YlhaaltaRajoitettuLaskuri</code>-luokka.</p>
  <p>Toteuta luokan <code>Kello</code> konstruktori ja puuttuvat
    metodit. Voit testata kelloasi seuraavalla pääohjelmalla:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Kello kello = new Kello(23, 59, 50);

        int i = 0;
        while( i &lt; 20) {
            System.out.println( kello );
            kello.etene();
            i++;
        }
    }
}
</pre>
  <p>Tulostuksen tulisi edetä seuraavasti:</p>
<pre>
23:59:50
23:59:51
23:59:52
23:59:53
23:59:54
23:59:55
23:59:56
23:59:57
23:59:58
23:59:59
00:00:00
00:00:01
...
</pre>
</div>
</div>

<!-- foobar -->

<h3>Olion sisällä listallinen olioita</h3>
<p>Laajennetaan <code>PainonvartijaYhdistys</code>-oliota siten, että yhdistys tallettaa kaikki jäsenensä <code>ArrayList</code>-olioon. Listalle tulee siis <code>Henkilo</code>-olioita. Yhdistykselle annetaan laajennetussa versiossa konstruktorin parametrina nimi:</p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
    private double alinPainoindeksi;
    private String nimi;
    private ArrayList&lt;Henkilo&gt; jasenet;

    public PainonvartijaYhdistys(String nimi, double alinPainoindeksi) {
        this.alinPainoindeksi = alinPainoindeksi;
        this.nimi = nimi;
        this.jasenet = new ArrayList&lt;Henkilo&gt;();
    }

//..
} 
</pre>
<p>Tehdään metodi jolla henkilö liitetään yhdistykseen. Metodi ei liitä yhdistykseen kuin tarpeeksi suuren painoindeksi omaavat henkilöt. Tehdään myös toString jossa tulostetaan jäsenten nimet:</p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
  // ...

    public boolean hyvaksytaanJaseneksi(Henkilo henkilo) {
        if ( henkilo.painoIndeksi() &lt; this.alinPainoindeksi ) {
            return false;
        }

        return true;
    }

    public void lisaaJaseneksi(Henkilo henkilo) {
        if ( !hyvaksytaanJaseneksi(henkilo) ) { // sama kuin hyvaksytaanJaseneksi(henkilo) == false
            return;
        }

        this.jasenet.add(henkilo);
    }

    public String toString() {
        String jasenetMerkkijonona = "";

        for ( Henkilo jasen : this.jasenet ) {
            jasenetMerkkijonona += "  " + jasen.getNimi() + "\n";
        }

        return "Painonvartijayhdistys " + this.nimi + " jäsenet: \n" + jasenetMerkkijonona;
    }
}
</pre>
<p>Metodi <code>lisaaJaseneksi</code> käyttää aiemmin tehtyä metodia <code>hyvaksytaanJaseneksi</code>.</p>
<p>Kokeillaan laajentunutta painonvartijayhdistystä:</p>
<pre class="sh_java">
public static void main(String[] args) {
    PainonvartijaYhdistys painonVartija = new PainonvartijaYhdistys("Kumpulan paino", 25);

    Henkilo matti = new Henkilo("Matti");
    matti.setPaino(86);
    matti.setPituus(180);
    painonVartija.lisaaJaseneksi(matti);

    Henkilo juhana = new Henkilo("Juhana");
    juhana.setPaino(64);
    juhana.setPituus(172);
    painonVartija.lisaaJaseneksi(juhana);

    Henkilo harri = new Henkilo("Harri");
    harri.setPaino(104);
    harri.setPituus(182);
    painonVartija.lisaaJaseneksi(harri);

    Henkilo petri = new Henkilo("Petri");
    petri.setPaino(112);
    petri.setPituus(173);
    painonVartija.lisaaJaseneksi(petri);

    System.out.println( painonVartija );
}
</pre>
<p>Tulostuksesta huomaamme, että Juhanaa ei kelpuutettu jäseneksi:</p>
<pre>
Painonvartijayhdistys Kumpulan paino jäsenet: 
Matti
Harri
Petri
</pre>

  
  <!-- CAST4 --> 
  
  <a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=Rut2pt5ztN0" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> 
  

<div class="tehtavat">   
  <div class="tehtava">
  <h3>Joukkueet ja pelaajat</h3>
  <h4 class="req">
<code>Joukkue</code>-luokka</h4>
  <p>Tee luokka <code>Joukkue</code>,
    johon tallennetaan joukkueen nimi (<code>String</code>).
    Tee luokkaan seuraavat metodit:</p>
  <ul>
<li> konstruktori, jolle annetaan joukkueen nimi</li>
    <li> <code>haeNimi</code>, joka palauttaa joukkueen nimen</li>
  </ul>
<p>Seuraava pääohjelma testaa luokan toimintaa:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");
        System.out.println("Joukkue: " + tapiiri.haeNimi());
    }
}
</pre>
  <p>Ohjelman tulostus on seuraava:</p>
  <pre>
Joukkue: FC Tapiiri
</pre>
  <h4 class="req">Pelaaja</h4>
  <p>Luo luokka <code>Pelaaja</code>, johon tallennetaan pelaajan nimi ja tehtyjen maalien määrä. Tee luokkaan kaksi konstruktoria: yksi jolle annetaan vain pelaajan nimi, toinen jolle annetaan sekä pelaajan nimi että pelaajan tekemien maalien määrä. Lisää pelaajalle myös metodit:</p>
  <ul>
<li> <code>haeNimi</code>, joka palauttaa pelaajan nimen</li>
    <li> <code>maalit</code>, joka palauttaa tehtyjen maalien määrän</li>
    <li> <code>toString</code>, joka palauttaa pelaajan merkkijonoesityksen</li>
  </ul>
<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");
        System.out.println("Joukkue: " + tapiiri.haeNimi());

        Pelaaja matti = new Pelaaja("Matti");
        System.out.println("Pelaaja: " + matti);

        Pelaaja pekka = new Pelaaja("Pekka", 39);
        System.out.println("Pelaaja: " + pekka);
    }
}
</pre>
<pre>
Joukkue: FC Tapiiri
Pelaaja: Matti, maaleja 0
Pelaaja: Pekka, maaleja 39
</pre>
  <h4 class="req">Pelaajat joukkueisiin</h4>
  <p>Lisää luokkaan <code>Joukkue</code> seuraavat metodit:</p>
  <ul>
<li> <code>lisaaPelaaja</code>, joka lisää pelaajan joukkueeseen</li>
    <li> <code>tulostaPelaajat</code>, joka tulostaa joukkueessa olevat pelaajat</li>
  </ul>
<p>Tallenna joukkueessa olevat pelaajat <code>Joukkue</code>-luokan
    sisäiseen <code>ArrayList</code>-listaan.</p>
  <p>Seuraava pääohjelma testaa luokan toimintaa:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");

        Pelaaja matti = new Pelaaja("Matti");
        Pelaaja pekka = new Pelaaja("Pekka", 39);

        tapiiri.lisaaPelaaja(matti);
        tapiiri.lisaaPelaaja(pekka);
        tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

        tapiiri.tulostaPelaajat();
    }
}
</pre>
  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>
<pre>
Matti, maaleja 0
Pekka, maaleja 39
Mikael, maaleja 1
</pre>
  <h4 class="req">Joukkueen maksimikoko ja nykyinen koko</h4>
  <p>Lisää luokkaan <code>Joukkue</code> seuraavat metodit:</p>
  <ul>
<li> <code>asetaMaksimikoko(int maksimikoko)</code>, joka asettaa joukkueen maksimikoon (eli maksimimäärän pelaajia)</li>
    <li> <code>koko</code>, joka palauttaa pelaajien määrän (<code>int</code>)</li>
  </ul>
<p>Joukkueen suurin sallittu pelaajamäärä on oletusarvoisesti 16. Metodin <code>asetaMaksimikoko</code> avulla tätä rajaa voi muuttaa. Muuta metodia <code>lisaaPelaaja</code> niin, että se ei lisää pelaajaa joukkueeseen, jos sallittu pelaajamäärä ylittyisi.</p>
  <p><strong>HUOM:</strong> muista lisätä oletusarvoinen maksimikoko koodiisi sillä muuten arvoksi tulee 0. Tämä aiheuttaa edellisen kohdan testien hajoamisen, sillä testit luovat oletusmaksimikokoisia joukkueita ja jos joukkueen maksimikoko on 0, ei joukkueeseen voi lisätä yhtään pelaajaa.</p>
  <p>Seuraava pääohjelma testaa luokan toimintaa:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");
        tapiiri.asetaMaksimikoko(1);

        Pelaaja matti = new Pelaaja("Matti");
        Pelaaja pekka = new Pelaaja("Pekka", 39);
        tapiiri.lisaaPelaaja(matti);
        tapiiri.lisaaPelaaja(pekka);
        tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

        System.out.println("Pelaajia yhteensä: " + tapiiri.koko());
    }
}
</pre>
<pre>
Pelaajia yhteensä: 1
</pre>
  <h4 class="req">Joukkueen maalit</h4>
  <p>Lisää luokkaan <code>Joukkue</code> metodi:</p>
  <ul>
<li> <code>maalit</code>, joka palauttaa joukkueen pelaajien tekemien maalien yhteismäärän.</li>
  </ul>
<p>Seuraava pääohjelma testaa luokan toimintaa:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");

        Pelaaja matti = new Pelaaja("Matti");
        Pelaaja pekka = new Pelaaja("Pekka", 39);
        tapiiri.lisaaPelaaja(matti);
        tapiiri.lisaaPelaaja(pekka);
        tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

        System.out.println("Maaleja yhteensä: " + tapiiri.maalit());
    }
}
</pre>
<pre>
Maaleja yhteensä: 40
</pre>
</div>
</div>
<h3>Metodi palauttaa olion</h3>
<p>Olemme nähneet metodeja jotka palauttavat totuusarvoja, lukuja, listoja ja merkkijonoja. On helppoa arvata, että metodi voi palauttaa minkä tahansa tyyppisen olion. Tehdään painovartijayhdistykselle metodi, jolla saadaan tietoon yhdistyksen suurimman painoindeksin omaava henkilö. </p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
    // ...

    public Henkilo suurinPainoindeksinen() {
        // jos jasenlista on tyhjä, palautetaan null-viite
        if ( this.jasenet.isEmpty() ) {
            return null;
        }

        Henkilo painavinTahanAsti = this.jasenet.get(0);

        for ( Henkilo henkilo : this.jasenet) {
            if ( henkilo.painoIndeksi() &gt; painavinTahanAsti.painoIndeksi() ) {
                painavinTahanAsti = henkilo;
            }
        }

        return painavinTahanAsti;
    }
}
</pre>
<p>Logiikaltaan metodi toimii samaan tapaan kuin suurimman luvun etsiminen taulukosta. Käytössä on apumuuttuja <code>painavinTahanAsti</code> joka laitetaan aluksi viittaamaan listan ensimmäiseen henkilöön. Sen jälkeen käydään lista läpi ja katsotaan tuleeko vastaan suuremman painoindeksin omaavia henkilöitä, jos tulee, niin otetaan viite talteen muuttujaan <code>painavinTahanAsti</code>. Lopuksi palautetaan muuttujan arvo eli <i>viite henkilöolioon</i>.</p>
<p>Tehdään lisäys edelliseen pääohjelmaan. Pääohjelma ottaa vastaan metodin palauttaman viitteen muuttujaan <code>painavin</code>.</p>
<pre class="sh_java">
public static void main(String[] args) {
    PainonvartijaYhdistys painonVartija = new PainonvartijaYhdistys("Kumpluan paino", 25);

    // ..

    Henkilo painavin = painonVartija.suurinPainoindeksinen();
    System.out.print("suurin painoindeksinen jäsen: " + painavin.getNimi() );
    System.out.println(" painoindeksi " + String.format( "%.2f", painavin.painoIndeksi() ) );
}
</pre>
<p>Tulostuu:</p>
<pre>
suurin painoindeksinen jäsen: Petri
painoindeksi 37,42
</pre>
<h3>Metodi palauttaa luomansa olion</h3>
<p>Edellisessä esimerkissä metodi palautti yhden painonVartija-olion sisältämistä Henkilo-olioista. On myös mahdollista, että metodi palauttaa kokonaan uuden olion. Seuraavassa yksinkertainen laskuri, jolla on metodi <code>kloonaa</code>, jonka avulla laskurista voidaan tehdä klooni, eli uusi laskurio-olio, jolla on luomishetkellä sama arvo kuin kloonattavalla laskurilla:</p>
<pre class="sh_java">
public Laskuri {
    private int arvo;

    public Laskuri(){
        this(0);
    }

    public Laskuri(int alkuarvo){
        this.arvo = alkuarvo;
    }

    public void kasvata(){
        this.arvo++;
    }

    public String toString(){
        return "arvo: "+arvo;
    }

    public Laskuri kloonaa(){
        // luodaan uusi laskuriolio, joka saa alkuarvokseen kloonattavan laskurin arvon
        Laskuri klooni = new Laskuri(this.arvo);

        // palautetaan klooni kutsujalle
        return klooni;
    }
}
</pre>
<p>Seuraavassa käyttöesimerkki:</p>
<pre class="sh_java">
Laskuri laskuri = new Laskuri();
laskuri.kasvata();
laskuri.kasvata();

System.out.println(laskuri);         // tulostuu 2

Laskuri klooni = laskuri.kloonaa();  

System.out.println(laskuri);         // tulostuu 2
System.out.println(klooni);          // tulostuu 2

laskuri.kasvata();
laskuri.kasvata();
laskuri.kasvata();
laskuri.kasvata();

System.out.println(laskuri);         // tulostuu 6
System.out.println(klooni);          // tulostuu 2

klooni.kasvata();

System.out.println(laskuri);         // tulostuu 6
System.out.println(klooni);          // tulostuu 3
</pre>
<p>Kloonattavan ja kloonin arvo on siis kloonauksen tapahduttua sama. Kyseessä on kuitenkin kaksi erillistä olioa, eli jatkossa kun toista laskureista kasvatetaan, ei kasvatus vaikuta toisen arvoon millään tavalla.</p>
<div class="tehtavat">
  <div class="tehtava">
  <h3>Päiväys</h3>
  <p>Tehtäväpohjan mukana tulee luvussa 24.7 esitelty luokka <code>Paivays</code>, jossa päivämäärä talletetaan oliomuuttujien <code>vuosi</code>, <code>kuukausi</code>, ja <code>paiva</code> avulla:
  </p>
<pre class="sh_java">
public class Paivays {
    private int paiva;
    private int kuukausi;
    private int vuosi;

    public Paivays(int paiva, int kuukausi, int vuosi) {
        this.paiva = paiva;
        this.kuukausi = kuukausi;
        this.vuosi = vuosi;
    }

    public String toString() {
        return this.paiva + "." + this.kuukausi + "." + this.vuosi;
    }

    public boolean aiemmin(Paivays verrattava) {
        // ensin verrataan vuosia
        if ( this.vuosi &lt; verrattava.vuosi ) {
            return true;
        }

        // jos vuodet ovat samat, verrataan kuukausia
        if ( this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi &lt; verrattava.kuukausi ) {
            return true;
        }

        // vuodet ja kuukaudet samoja, verrataan päivää
        if ( this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi == verrattava.kuukausi &amp;&amp;
            this.paiva &lt; verrattava.paiva ) {
            return true;
        }

        return false;
    }
}
</pre>
  <p>Tässä tehtäväsarjassa laajennetaan luokkaa.</p>
  <h4 class="req">Seuraava päivä</h4>
  <p>Toteuta metodi <code>public void etene()</code>, joka siirtää päiväystä yhdellä päivällä. Tässä tehtävässä oletetaan, että jokaisessa kuukaudessa on 30 päivää. Huom! Sinun tulee <em>tietyissä</em> tilanteissa muuttaa kuukauden ja vuoden arvoa.</p>
  <h4 class="req">Tietty määrä päiviä eteenpäin</h4>
  <p>Toteuta metodi <code>public void etene(int montakoPaivaa)</code>, joka siirtää päiväystä annetun päivien määrän verran. Käytä apuna edellisessä tehtävässä toteutettua metodia <code>etene()</code>.</p>
  <h4 class="req">Ajan kuluminen</h4>
  <p>Lisätään <code>Paivays</code>-olioon mahdollisuus edistää aikaa. Tee oliolle metodi <code>Paivays paivienPaasta(int paivia)</code>, joka luo <strong>uuden</strong> <code>Paivays</code>-olion, jonka päiväys on annetun päivien lukumäärän verran suurempi kuin oliolla, jolle sitä kutsuttiin. Voit edelleen olettaa, että jokaisessa kuukaudessa on 30 päivää. Huomaa, että vanhan päiväysolion on pysyttävä muuttumattomana! </p>
  <p>Koska metodissa on luotava <b>uusi olio</b>, tulee rungon olla suunnilleen seuraavanlainen:</p>
  <pre class="sh_java">
public Paivays paivienPaasta(int paivia){
    Paivays uusiPaivays = new Paivays( ... );

    // tehdään jotain...

    return uusiPaivays;
}

</pre>
  <p>Ohessa on esimerkki metodin toiminnasta. </p>
  <pre class="sh_java">
public static void main(String[] args) {
    Paivays pvm = new Paivays(25, 2, 2011);
    Paivays uusi_pvm = pvm.paivienPaasta(7);
    for (int i = 1; i &lt;= 7; ++i) {
        System.out.println("Perjantai " + i + " viikon kuluttua on " + uusi_pvm);
        uusi_pvm = uusi_pvm.paivienPaasta(7);
    }
    System.out.println("Tämän viikon perjantai on " + pvm);
    System.out.println("Päivämäärä 790:n päivän päästä tämän viikon perjantaista on  " + pvm.paivienPaasta(790));
}
</pre>
  <p>Ohjelma tulostaa:</p>
<pre>
Perjantai 1 viikon kuluttua on 2.3.2011
Perjantai 2 viikon kuluttua on 9.3.2011
Perjantai 3 viikon kuluttua on 16.3.2011
Perjantai 4 viikon kuluttua on 23.3.2011
Perjantai 5 viikon kuluttua on 30.3.2011
Perjantai 6 viikon kuluttua on 7.4.2011
Perjantai 7 viikon kuluttua on 14.4.2011
Tämän viikon perjantai on 25.2.2011
Päivämäärä 790:n päivän päästä tämän viikon perjantaista on  5.5.2013
</pre>
  <p> <strong>Huom!</strong> Sen sijaan, että muuttaisimme vanhan olion tilaa
    palautamme uuden olion. Kuvitellaan, että <code>Paivays</code>-luokalle on
    olemassa metodi <code>edista</code>, joka toimii vastaavasti kuin ohjelmoimamme
    metodi, mutta se muuttaa vanhan olion tilaa.
    Tällöin seuraava koodin pätkä tuottaisi ongelmia. </p>
  <pre class="sh_java">
Paivays nyt = new Paivays(20,2,2011);
Paivays viikonPaasta = nyt;
viikonPaasta.edista(7);
System.out.println("Nyt: " + nyt);
System.out.println("Viikon päästä: " + viikonPaasta);
</pre>
  <p>Ohjelman tulostus olisi seuraavanlainen:</p>
<pre>
Nyt 27.2.2011
Viikon päästä 27.2.2011
</pre>
  <p>Tämä johtuu siitä, että tavallinen sijoitus kopioi ainoastaan viitteen olioon. Siis
    itse asiassa ohjelman oliot <code>nyt</code> ja <code>viikonPaasta</code> viittavaat <strong>yhteen ja samaan</strong> <code>Paivays</code>-olioon. </p>
</div>

  <div class="tehtava">
  <h3>Päivämäärien erotus</h3>
  <p>Jatketaan luokan Päiväys laajentamista. Tämä tehtävä ei riipu edellisestä tehtävästä, saat tehtäväpohjan mukana Paivays-luokan jossa ei ole edellisen tehtävän lisäyksiä.</p>
  <h4 class="req">Kahden päiväyksen erotus vuosissa</h4>
  <p><b>Lisää päiväykselle metodi</b> <code>public int erotusVuosissa(Paivays verrattava)</code>, jonka avulla saadaan selville päiväyksen ja verrattavan päiväyksen ero vuosissa. <b>Huomioi seuraavat: </b></p>
  <ul>
<li> Ensimmäisessä versiossa metodi toimii vasta aika karkealla tasolla, se ainoastaan laskee verrattavien päiväysten vuosilukujen erotuksen. </li>
    <li> Metodin tarvitsee toimia ainoastaan siten, että parametriksi annettava päivämäärä on aiempi kuin se päivämäärä jolle metodia kutsutaan. </li>
  </ul>
<p>Seuraava pääohjelma demonstroi metodin käyttöä:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Paivays eka = new Paivays(24, 12, 2009);
        Paivays toka = new Paivays(1, 1, 2011);
        Paivays kolmas = new Paivays(25, 12, 2010);

        System.out.println( toka + " ja " + eka + " ero vuosissa: " + toka.erotusVuosissa(eka) );

        System.out.println( kolmas + " ja " + eka + " ero vuosissa: " + kolmas.erotusVuosissa(eka) );

        System.out.println( toka + " ja " + kolmas + " ero vuosissa: " + toka.erotusVuosissa(kolmas) );
    }
}
</pre>
  <p>Tulos näyttää seuraavalta:</p>
<pre>
1.1.2011 ja 24.12.2009 ero vuosissa: 2
25.12.2010 ja 24.12.2009 ero vuosissa: 1
1.1.2011 ja 25.12.2010 ero vuosissa: 1
</pre>
  <h4 class="req">Tarkennettu versio</h4>
  <p>Vuosien laskenta ei edellisessä versiossa ollut vielä kovin tarkkaa. Esim. 1.1.2011 ja 25.12.2010 välillä ilmoitettiin olevan vuoden ero. <b>Tarkennetaan metodin toiminta sellaiseksi, että se osaa laskea vuodet kunnolla. Laske erotukseen mukaan vain täydet vuodet.</b> Eli vaikka päiväysten ero olisi 1 vuosi ja 364 päivää, ilmoittaa metodi eroksi vuoden.</p>
  <p> Metodin tämänkin version tarvitsee toimia ainoastaan siten, että parametriksi annettava päivämäärä on aiempi kuin se päivämäärä jolle metodia kutsutaan. </p>
  <p>Edellisen esimerkin tulos on nyt:</p>
<pre>
1.1.2011 ja 24.12.2009 ero vuosissa: 1
25.12.2010 ja 24.12.2009 ero vuosissa: 1
1.1.2011 ja 25.12.2010 ero vuosissa: 0
</pre>
  <h4>Ja lopullinen versio</h4>
  <p>Laitetaan metodi toimimaan samoin riippumatta onko parametrina annettava päiväys myöhempi vai aiempi kuin päiväys mille metodia kutsutaan. Esimerkkipääohjelma:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Paivays eka = new Paivays(24, 12, 2009);
        Paivays toka = new Paivays(1, 1, 2011);
        Paivays kolmas = new Paivays(25, 12, 2010);

        System.out.println( eka + " ja " + toka + " ero vuosissa: " + toka.erotusVuosissa(eka) );
        System.out.println( toka + " ja " + eka + " ero vuosissa: " + eka.erotusVuosissa(toka) );
        System.out.println( eka + " ja " + kolmas + " ero vuosissa: " + kolmas.erotusVuosissa(eka) );
        System.out.println( kolmas + " ja " + eka + " ero vuosissa: " + eka.erotusVuosissa(kolmas) );
        System.out.println( kolmas + " ja " + toka + " ero vuosissa: " + toka.erotusVuosissa(kolmas) );
        System.out.println( toka + " ja " + kolmas + " ero vuosissa: " + kolmas.erotusVuosissa(toka) );
    }
}
</pre>
  <pre>
24.12.2009 ja 1.1.2011 ero vuosissa: 1
1.1.2011 ja 24.12.2009 ero vuosissa: 1
24.12.2009 ja 25.12.2010 ero vuosissa: 1
25.12.2010 ja 24.12.2009 ero vuosissa: 1
1.1.2011 ja 25.12.2010 ero vuosissa: 0
25.12.2010 ja 1.1.2011 ero vuosissa: 0
</pre>
</div>
<div class="tehtava">
<h3>Luokan Henkilö muokkaaminen</h3>
  <h4 class="req">Iän laskeminen syntymäpäivän perusteella</h4>
  <p>Luvussa 24.9. lisättiin henkilölle oliomuuttujaksi syntymäpäivän kertova Paivays-olio. Samalla todettiin, että oliomuuttuja <code>ika</code> kannattaa poistaa sillä iän pystyy laskemaan päiväyksen ja syntymäpäivän avulla. </p>
  <p>Toteuta metodi <code>ika</code> joka palauttaa henkilön iän.</p>
  <p><b>Huom:</b> edellisessä tehtävässä lisättiin luokalle <code>Paivays</code> metodi <code>public int erotusVuosissa(Paivays verrattava)</code>. Kannattaa kopioida metodi tässä tehtävässä olevaan luokkaan, se helpottaa tehtävän tekemistä oleellisesti!</p>
  <pre class="sh_java">
import java.util.Calendar;

public class Henkilo {
    private String nimi;
    private Paivays syntymaPaiva;

    public Henkilo(String nimi, int pp, int kk, int vv) {
        this.nimi = nimi;
        this.syntymaPaiva = new Paivays(pp, kk, vv);
    }

    public int ika() {
        // laske henkilön ikä syntymäpäivän ja tämän päivän perusteella
        // tämä päivä saadaan selville seuraavasti
        // Calendar.getInstance().get(Calendar.DATE);
        // Calendar.getInstance().get(Calendar.MONTH) + 1; // tammikuun numero on 0 joten lisätään 1
        // Calendar.getInstance().get(Calendar.YEAR);
    }

    public String getNimi() {
        return this.nimi;
    }

    public String toString() {
        return this.nimi +", syntynyt "+ this.syntymaPaiva;
    }
}
</pre>
  <p>Voit testata Henkilöä seuraavalla pääohjelmalla. Lisää myös itsesi ohjelmaan ja varmista että ikäsi tulostuu oikein.</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka", 15, 2, 1993);
        Henkilo antti = new Henkilo("Antti", 1, 3, 1955);

        System.out.println( antti.getNimi() + " ikä " + antti.ika() + " vuotta");
        System.out.println( pekka.getNimi() + " ikä " + pekka.ika() + " vuotta");
    }
}
</pre>
  <p>Tulostus:</p>
  <pre>
Antti ikä 57 vuotta
Pekka ikä 19 vuotta
</pre>
<h4 class="req">Iän vertailu syntymäpäivien perusteella</h4>
  <p>Tee henkilölle metodi jonka avulla se vertaa ikäänsä parametrina annettuun henkilöön. Jos henkilö on vanhempi eli syntynyt aiemmin, palauttaa metodi true ja muuten false.</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public boolean vanhempiKuin(Henkilo verrattava) {
        // vertaa henklöiden ikiä käyttäen henkilöiden syntymäpäivää
    }
}
</pre>
  <p>Ja testaa laajennettua Henkilö-luokkaa esim. seuraavasti:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka", 15, 2, 1983);
        Henkilo martin = new Henkilo("Martin", 1, 3, 1983);

        System.out.println( martin.getNimi() + " vanhempi kuin " +  pekka.getNimi() + ": "+ martin.vanhempiKuin(pekka) );
        System.out.println( pekka.getNimi() + " vanhempi kuin " +  martin.getNimi() + ": "+ pekka.vanhempiKuin(martin) );
    } 
}  
</pre>
  <p>Tulostus:</p>
<pre>
Martin vanhempi kuin Pekka: false
Pekka vanhempi kuin Martin: true
</pre>
  <h4>Uusia konstruktoreja</h4>
  <p>Tee Henkilo-luokalle kaksi uutta konstruktoria:</p>
  <ul>
<li>
<code>public Henkilo(String nimi, Paivays syntymapaiva)</code> - jossa konstruktori käyttää annettua Paivays-oliota syntymäpäivänä</li>
    <li>
<code>public Henkilo(String nimi)</code> - jossa konstruktori määrittää syntymäpäiväksi tämänhetkisen päivän</li>
  </ul>
<p>Testaa uusia konstruktoreja esim. seuraavasti:</p>
  <pre class="sh_java">
public class Main {
      public static void main(String[] args) {
      Henkilo pekka = new Henkilo("Pekka", new Paivays(15, 2, 1983));
      Henkilo sepe = new Henkilo("Sepe");

      System.out.println( pekka );
      System.out.println( sepe );
    }
}
</pre>
  <p>Esimerkkitulostus:</p>
  <pre>
Pekka, syntynyt 15.2.1983
Sepe, syntynyt 9.2.2012
</pre>
  <p><b>Huom:</b> jälkimmäinen rivi riippuu päivämäärästä, jolloin koodi ajetaan!</p>
</div>
</div>
</div>
</section>