<section class="viikkoraja" id="3"><div class="viikkoraja">Viikko 3</div>  
<div class="viikkoraja-mooc" id="Viikko 3" deadline="10.3.2013 23.59" data-first-chapter-index="13" data-first-exercise-index="43" data-first-week-index="3" data-first-chapter-index-mooc="13" data-first-exercise-index-mooc="43" data-first-week-index-mooc="3" tekija="Arto Vihavainen, Matti Luukkainen">


  <h2>Lisää metodeista</h2>
  <p>Edellisellä viikolla opettelimme kirjoittamaan omia metodeja. Metodien avulla voimme jäsennellä ohjelmaa pienemmiksi hyvin nimetyiksi. selkeän tehtävän omaaviksi loogisiksi kokonaisuuksiksi. Tämä sekä helpottaa ongelmanratkaisua että parantaa ohjelman luettavuutta niin ohjelmoijan kuin ohjelmaa myöhemmin mahdollisesti ylläpitävänkin osalta. Tästä lähtien oikeastaan jokainen tekemämme ohjelma sisältää metodeita.</p>
  <p>Jatketaan edelleen metodien parissa.</p>
  <h3>Metodit ja muuttujien näkyvyys</h3>
  <p>Yritetään muuttaa metodin sisältä pääohjelman muuttujan arvoa.</p>
  <pre class="sh_java">
// pääohjelma
public static void main(String[] args) {
    int luku = 1;
    kasvataKolmella();
}

// metodi
public static void kasvataKolmella() {
    luku = luku + 3;
}
</pre>
  <p>Ohjelma ei kuitenkaan toimi, sillä metodi ei näe pääohjelman muuttujaa <code>luku</code>.</p>
  <p>Yleisemminkin voi todeta, että pääohjelman muuttujat eivät näy metodien sisään, ja metodin muuttujat eivät näy muille metodeille tai pääohjelmalle. Ainoa keino viedä metodille tietoa ulkopuolelta on parametrin avulla.</p>
  <pre class="sh_java">
// pääohjelma
public static void main(String[] args) {
    int luku = 1;
    System.out.println("Pääohjelman muuttujan luku arvo: " + luku);
    kasvataKolmella(luku);
    System.out.println("Pääohjelman muuttujan luku arvo: " + luku);
}

// metodi
public static void kasvataKolmella(int luku) {
    System.out.println("Metodin parametrin luku arvo: " + luku);
    luku = luku + 3;
    System.out.println("Metodin parametrin luku arvo: " + luku);
}
</pre>
  <p>Yllä metodilla kasvataKolmella on parametri <code>luku</code>. Parametri luku <em>kopioidaan</em> metodin käyttöön. Kun yllä oleva ohjelma suoritetaan, nähdään seuraavanlainen tulostus.</p>
  <pre>
Pääohjelman muuttujan luku arvo: 1
Metodin parametrin luku arvo: 1
Metodin parametrin luku arvo: 4
Pääohjelman muuttujan luku arvo: 1
</pre>
  <p>Parametrina annettu luku siis <em>kopioitiin</em> metodin käyttöön. Jotta saisimme luvun uuden arvon myös pääohjelmaan, tulee metodin palauttaa arvo.</p>
  <h3>Metodin paluuarvot</h3>
  <p>Metodi voi palauttaa arvon. Tähän mennessä kurssilla olleissa esimerkeissä ja tehtävissä metodit eivät palauttaneet mitään. Tämä on merkitty kirjoittamalla metodin ylimmälle riville heti nimen vasemmalle puolelle <em>void</em>.</p>
  <pre class="sh_java">
public static void kasvataKolmella() {
...
</pre>
  <p> Arvon palauttavaa metodia määriteltäessä täytyy määritellä myös palautettavan arvon tyyppi. Paluuarvon tyyppi merkitään metodin nimen vasemmalle puolelle. Seuraavassa metodi joka palauttaa aina kokonaisluvun 10, metodin tyyppi on <code>int</code>. Palautus tapahtuu komennolla return: </p>
  <pre class="sh_java">
public static int palautetaanAinaKymppi() {
    return 10;
}
</pre>
  <p>Jotta metodin palauttamaa arvoa voisi käyttää, tulee paluuarvo ottaa talteen muuttujaan:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = palautetaanAinaKymppi();

    System.out.println( "metodi palautti luvun " + luku );
}
</pre>
  <p>Metodin paluuarvo sijoitetaan <code>int</code>-tyyppiseen muuttujaan aivan kuin mikä tahansa muukin int-arvo. Paluuarvo voi toimia myös osana mitä tahansa lauseketta: </p>
  <pre class="sh_java">
double luku = 4 * palautetaanAinaKymppi() + (palautetaanAinaKymppi() / 2) - 8;

System.out.println( "laskutoimituksen tulos " + luku );
</pre>
  <p> Kaikki muuttujatyypit, mitä olemme tähän mennessä nähneet, voidaan palauttaa metodista:</p>
  <pre class="sh_java">
public static void metodiJokaEiPalautaMitaan() {
    // metodin runko
}

public static int metodiJokaPalauttaaKokonaisLuvun() {
    // metodin runko, tarvitsee return-komennon
}

public static String metodiJokaPalauttaaTekstin() {
    // metodin runko, tarvitsee return-komennon
}

public static double metodiJokaPalauttaaLiukuluvun() {
    // metodin runko, tarvitsee return-komennon
}
</pre>
  <p>Jos metodille määritellään paluuarvo, on sen myös pakko palauttaa arvo, esimerkiksi seuraava metodi on virheellinen.</p>
  <pre class="sh_java">
public static String virheellinenMetodi() {
    System.out.println("Väitän palauttavani merkkijonon, mutten palauta sitä.");
}
</pre>
  <p>Seuraavassa esimerkissä määritellään metodi summan laskemiseen.  Tämän jälkeen metodia käytetään laskemaan luvut 2 ja 7 yhteen. Metodikutsusta saatava paluuarvo asetetaan muuttujaan <code>lukujenSumma</code>.</p>
  <pre class="sh_java">
public static int summa(int eka, int toka) {
    return eka + toka;
}
</pre>
  <p>Metodin kutsu:</p>
  <pre class="sh_java">
int lukujenSumma = summa(2, 7);
// lukujenSumma on nyt 9
</pre>
  <p>Laajennetaan edellistä esimerkkiä siten, että käyttäjä syöttää luvut.</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    System.out.print("Anna ensimmäinen luku: ");
    int eka = Integer.parseInt( lukija.nextLine() );

    System.out.print("Anna toinen luku: ");
    int toka = Integer.parseInt( lukija.nextLine() );

    System.out.print("Luvut ovat yhteensä: " + summa(eka,toka) );
}

public static int summa(int eka, int toka) {
    return eka + toka;
}
</pre>
  <p> Kuten huomataan, metodin paluuarvoa ei tarvitse välttämättä sijoittaa muuttujaan, se voi olla osana tulostuslausetta aivan kuten mikä tahansa muukin int-arvo.</p>
  <p>Huomaa, että metodin parametrien nimillä ja metodin kutsujan puolella määritellyillä muuttujan nimillä ei ole mitään tekemistä keskenään. Edellisessä esimerkissä sekä pääohjelman muuttujat että metodin parametrit olivat "sattumalta" nimetty samoin (eli <code>eka</code> ja <code>toka</code>). Seuraava toimisi aivan yhtä hyvin:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    System.out.print("Anna ensimmäinen luku: ");
    int luku1 = Integer.parseInt( lukija.nextLine() );

    System.out.print("Anna toinen luku: ");
    int luku2 = Integer.parseInt( lukija.nextLine() );

    System.out.print("Luvut ovat yhteensä: " + summa(luku1, luku2) );
}

public static int summa(int eka, int toka) {
    return eka + toka;
}
</pre>
  <p>Nyt pääohjelman muuttujan <code>luku1</code> arvo kopioituu metodin parametrin <code>eka</code> arvoksi ja pääohjelman muuttujan <code>luku2</code> arvo kopioituu metodin parametrin <code>toka</code> arvoksi.</p>
  <p>Seuraavassa esimerkissä metodia summa kutsutaan kokonaisluvuilla, jotka saadaan <code>summa</code>-metodin paluuarvoina. </p>
  <pre class="sh_java">
int eka = 3;
int toka = 2;

int monenLuvunSumma = summa(summa(1, 2), summa(eka, toka));
// 1) suoritetaan sisemmät metodit:
//    summa(1, 2) = 3   ja summa(eka, toka) = 5
// 2) suoritetaan ulompi metodi:
//    summa(3, 5) = 8 
// 3) muuttujan monenLuvunSumma arvoksi siis tulee 8

</pre>
  <h3>Metodin omat muuttujat</h3>
  <p>Seuraava metodi laskee syötteinään saamiensa lukujen keskiarvon. Metodi käyttää apumuuttujia <code>summa</code> ja <code>ka</code>. Metodin sisäisen muuttujan määrittely tapahtuu tutulla tavalla.</p>
  <pre class="sh_java">
public static double keskiarvo(int luku1, int luku2, int luku3) {

    int summa = luku1 + luku2 + luku3;
    double ka = summa / 3.0;

    return ka;
}
</pre>
  <p>Metodin kutsu voi tapahtua esim seuraavasti</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    System.out.print("Anna ensimmäinen luku: ");
    int eka = Integer.parseInt( lukija.nextLine() );

    System.out.print("Anna toinen luku: ");
    int toka = Integer.parseInt( lukija.nextLine() );

    System.out.print("ja kolmas luku: ");
    int kolmas = Integer.parseInt( lukija.nextLine() );

    double keskiarvonTulos = keskiarvo(eka, toka, kolmas);

    System.out.print("Lukujen keskiarvo: " + keskiarvonTulos );
}
</pre>
  <p>Huomaa että metodin sisäiset muuttujat <code>summa</code> ja <code>ka</code> eivät näy pääohjelmaan. Yksi yleinen aloittelijan virhe olisikin yrittää käyttää metodia seuraavasi:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    // annetaan arvot muuttujille eka, toka ja kolmas

    keskiarvo(eka, toka, kolmas);

    // yritetään käyttää metodin sisäistä muuttujaa, EI TOIMI!
    System.out.print("Lukujen keskiarvo: " + ka );
}
</pre>
  <p>Myös seuraavanlaista virhettä näkee usein:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    // annetaan arvot muuttujille eka, toka ja kolmas

    keskiarvo(eka, toka, kolmas);

    // yritetään käyttää pelkkää metodin nimeä, EI TOIMI!
    System.out.print("Lukujen keskiarvo: " + keskiarvo );
}
</pre>
  <p>Eli tässä yritettiin käyttää pelkkää metodin nimeä muuttujamaisesti. Toimiva tapa metodin tuloksen sijoittamisen apumuuttujaan lisäksi on suorittaa metodikutsu suoraan tulostuslauseen sisällä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int eka = 3;
    int toka = 8;
    int kolmas = 4; 

    // kutsutaan metodia tulostuslauseessa, TOIMII!
    System.out.print("Lukujen keskiarvo: " + keskiarvo(eka, toka, kolmas) );
}
</pre>
  <p>Tässä siis ensin tapahtuu metodikutsu joka palauttaa arvon 5.0 joka sitten tulostetaan tulostuskomennon avulla.</p>
  <p>Screencast aiheesta:</p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=zEHvycTo81c" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a>



  <div class="tehtavat" id="viikko3">
    <div class="tehtava">
    <h3 class="req">Lukujen summa</h3>
    <p>Tee metodi <code>summa</code>, joka laskee parametrina olevien lukujen summan.</p>
    <p>Tee metodi seuraavaan runkoon:</p>
<pre class="sh_java">
public static int summa(int luku1, int luku2, int luku3, int luku4) {
    // kirjoita koodia tähän
    // muista että metodissa on oltava (lopussa) return!
}

public static void main(String[] args) {
    int vastaus = summa(4, 3, 6, 1);
    System.out.println("Summa: " + vastaus);
}
</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Summa: 14
</pre>
    <p><b>Huom:</b> kun tehtävässä sanotaan että metodin pitää <em>palauttaa</em> jotain, tarkoittaa tämä sitä että metodissa tulee olla määritelty paluutyyppi ja <code>return</code>-komento jolla haluttu asia palautetaan. Metodi ei itse tulosta (eli käytä komentoa <code>System.out.println(..)</code>), tulostuksen hoitaa metodin kutsuja, eli tässä tapauksessa pääohjelma.</p>
  </div>
  <div class="tehtava">
    <h3 class="req">Pienin</h3>
    <p>Tee metodi <code>pienin</code>, joka palauttaa parametrina saamistaan luvuista pienemmän arvon. Jos lukujen arvo on sama, voidaan palauttaa kumpi tahansa luvuista.</p>
    <pre class="sh_java">
public static int pienin(int luku1, int luku2) {
    // kirjoita koodia tähän
    // älä tulosta metodin sisällä mitään

    // lopussa oltava komento return
}

public static void main(String[] args) {
    int vastaus =  pienin(2, 7);
    System.out.println("Pienin: " + vastaus);
}
</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Pienin: 2
</pre>
</div>
<div class="tehtava">
    <h3>Suurin</h3>
    <p>Tee metodi <code>suurin</code>, joka saa kolme lukua ja palauttaa niistä suurimman. Jos suurimpia arvoja on useita, riittää niistä jonkun palauttaminen. Tulostus tapahtuu pääohjelmassa.</p>
    <pre class="sh_java">
public static int suurin(int luku1, int luku2, int luku3) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    int vastaus =  suurin(2, 7, 3);
    System.out.println("Suurin: " + vastaus);
}
</pre>
    <p>Ohjelman tulostus:</p>
    <pre>
Suurin: 7
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Lukujen keskiarvo</h3>
    <p>Tee metodi <code>keskiarvo</code>, joka laskee parametrina olevien lukujen keskiarvon. Metodin sisällä tulee käyttää apuna tehtävän 43 metodia <code>summa</code>!</p>
    <p>Tee metodi seuraavaan runkoon:</p>
    <pre class="sh_java">
public static int summa(int luku1, int luku2, int luku3, int luku4) {
    // kopioi koodi tehtävästä 43
}

public static double keskiarvo(int luku1, int luku2, int luku3, int luku4) {
    // kirjoita koodia tähän
    // laske alkioiden summa kutsumalla metodia summa
}

public static void main(String[] args) {
    double vastaus = keskiarvo(4, 3, 6, 1);
    System.out.println("Keskiarvo: " + vastaus);
}

</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Keskiarvo: 3.5
</pre>
    <p>Muistathan miten kokonaisluku (<tt>int</tt>) muutetaan desimaaliluvuksi (<tt>double</tt>)!</p>
  </div>
</div>
  <h2 id="merkkijonot">Merkkijonot</h2>
  <p> Tässä luvussa tutustaan tarkemmin Javan merkkijonoihin, eli <code>String</code>:eihin. 
    Olemme jo käyttäneet <code>String</code>-tyyppisiä muuttujia tulostuksen yhteydessä sekä
    oppineet vertailemaan merkkijonoja toisiinsa. Merkkijonoja vertailtiin toisiinsa <em>kutsumalla</em> merkkijonon <code>equals()</code>-metodia. </p>
  <pre class="sh_java">
String elain = "Koira";

if( elain.equals("Koira") ) {
    System.out.println(elain + " sanoo vuh vuh");
} else if ( elain.equals("Kissa") ) {
    System.out.println(elain + " sanoo miau miau");
}
</pre>
  <p>Merkkijonoilta voi kysyä niiden pituutta kirjoittamalla merkkijonon perään <code>.length()</code> eli kutsumalla merkkijonolle sen pituuden kertovaa metodia. </p>
  <pre class="sh_java">
String banaani = "banaani";
String kurkku = "kurkku";
String yhdessa = banaani + kurkku;

System.out.println("Banaanin pituus on " + banaani.length());
System.out.println("Kurkku pituus on " + kurkku.length());
System.out.println("Sanan " + yhdessa + " pituus on " + yhdessa.length());
</pre>
  <p> Edellä kutsutaan metodia <code>length()</code> kolmelle eri merkkijonolle. Kutsu <code>banaani.length()</code> kutsuu nimenomaan merkkijonon <code>banaani</code> pituuden kertovaa metodia, kun taas <code>kurkku.length()</code> on merkkijonon <code>kurkku</code> pituuden kertovan metodin kutsu, jne.Pisteen vasemman puoleinen osa kertoo kenen metodia kutsutaan.</p>
  <p>Javassa on erillinen <code>char</code>-tietotyyppi kirjaimia varten. Yksittäiseen <code>char</code>-muuttujaan voi tallentaa yhden kirjaimen. Merkkijonolta voidaan kysyä sen kirjaimia kirjaimen paikan perusteella käyttämällä <code>charAt()</code>-metodia. <strong>Huomaa</strong> että laskeminen alkaa nollasta!</p>
  <pre class="sh_java">
String kirja = "Kalavale";

char merkki = kirja.charAt(3);
System.out.println("Kirjan neljäs kirjain on " + merkki); //tulostaa "a"
  </pre>
  <p>Koska merkkijonon kirjaimet numeroidaan (eli teknisemmin ilmaistuna merkkijonoja indeksoidaan) alkaen paikasta 0, on merkkijonon viimeisen kirjaimen numero eli indeksi "merkkijonon pituus miinus yksi", eli <code>kirja.charAt(kirja.length()-1)</code>. Esimerkiksi seuraava kaataa ohjelman: yritämme hakea kirjainta kohdasta jota ei ole olemassa.</p>
  <pre class="sh_java">
char merkki = kirja.charAt(kirja.length());
  </pre>
  <div> <big><b>NetBeans-vihje</b></big>
    <ul>
<li> Kaikki NetBeans-vihjeet löytyvät 

    <a class="ahy" href="netbeans.html">täältä</a>
    <a class="amooc" href="http://mooc.cs.helsinki.fi/ohjelmointi/ohjeita#netbeans">täältä</a>
      </li>
<li> <b>Uudelleennimentä</b>
        <p>Muuttujat, metodit ja ensi viikolla opittavat luokat kannattaa nimetä kuvaavasti. Usein käy, että valittu nimi on hieman epäkuvaava ja tulee tarve nimen muuttamiselle. NetBeans:issa tämä on todella helppoa. Maalaa huono nimi jostain kohtaa koodiasi hiirellä. Paina (yhtäaikaa) ctrl ja r ja kirjoita muuttujalle/metodille uusi nimi. </p>
      </li>
    </ul>
</div>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Nimen pituus</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa,
      kuinka monta kirjainta siinä on.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
Kirjainmäärä: 5
</pre>
<pre>
Anna nimi: <font color="red">Katariina</font>
Kirjainmäärä: 9
</pre>
    <p><strong>Huom!</strong> Rakenna ohjelmasi niin että laitat pituuden
      laskemisen omaan metodiinsa: <code>public static int laskeKirjaimet(String merkkijono)</code>. Testit testaavat sekä
      metodia <code>laskeKirjaimet</code> että koko ohjelman toimintaa.</p>
    </div>
    <div class="tehtava">
    <h3 class="req">Ensimmäinen kirjain</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa
nimen ensimmäisen kirjaimen.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
Ensimmäinen kirjain: P
</pre>
<pre>
Anna nimi: <font color="red">Katariina</font>
Ensimmäinen kirjain: K
</pre>
    <p><strong>Huom!</strong> Rakenna ohjelmasi niin että laitat
      ensimmäisen kirjaimen hakemisen omaan metodiinsa: <code>public static char
      ensimmainenKirjain(String merkkijono)</code>. Testit testaavat sekä
      metodia <code>ensimmainenKirjain</code> että koko ohjelman
      toimintaa.</p>
    </div>
    <div class="tehtava">
    <h3>Viimeinen kirjain</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa
      nimen viimeisen kirjaimen.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
Viimeinen kirjain: a
</pre>
<pre>
Anna nimi: <font color="red">Katariina</font>
Viimeinen kirjain: a
</pre>
    <p><strong>Huom!</strong> Rakenna ohjelmasi niin että laitat
      viimeisen kirjaimen hakemisen omaan metodiinsa: <code>public static char
      viimeinenKirjain(String merkkijono)</code>. Testit testaavat sekä
      metodia <code>viimeinenKirjain</code> että koko ohjelman
      toimintaa.</p>
    </div>
    <div class="tehtava">
    <h3 class="req">Ensimmäiset kirjaimet erikseen</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa
      sen kolme ensimmäistä kirjainta erikseen. Jos nimen pituus on alle kolme, ei ohjelma tulosta mitään. Tehtävässä ei edellytetä erillisten metodien luomista.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
1. kirjain: P
2. kirjain: e
3. kirjain: k
</pre>
<pre>
Anna nimi: <font color="red">me</font>
</pre>
    <p><strong>Huom:</strong> ole tässä ja seuraavassa tehtävässä erityisen tarkka tulostusasun suhteen! Tulostuksessa tulee olla yksi välilyönti sekä pisteen että kaksoispisteen jälkeen!</p>
  </div>
  <div class="tehtava">
    <h3 class="req">Kirjaimet erikseen</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa
      sen kirjaimet erikseen. Tehtävässä ei edellytetä erillisen metodin luomista.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
1. kirjain: P
2. kirjain: e
3. kirjain: k
4. kirjain: k
5. kirjain: a
</pre>
    <p><b>Vihje: <code>while</code>-toistolauseesta on tässä apua!</b></p>
<pre>
Anna nimi: <font color="red">Katariina</font>
1. kirjain: K
2. kirjain: a
3. kirjain: t
4. kirjain: a
5. kirjain: r
6. kirjain: i
7. kirjain: i
8. kirjain: n
9. kirjain: a
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Nimen kääntäminen</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja
      tulostaa sen väärinpäin. Erillistä metodia nimen kääntämiselle ei tarvitse tehdä.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
Väärinpäin: akkeP
</pre>
<pre>
Anna nimi: <font color="red">Katariina</font>
Väärinpäin: aniirataK
</pre>
    <p><b>Vihje: Yksittäisen merkin saa tulostettua komennolla <code>System.out.print()</code></b></p>
  </div>
</div>
  <h3 id="merkkijonon_muita">Muita merkkijonojen metodeja</h3>
  <p> Merkkijonosta halutaan usein lukea jokin tietty osa. Tämä onnistuu mekkkijonojen eli String-luokan metodilla <code>substring</code>. Sitä voidaan käyttää kahdella tavalla: yksiparametrisenä palauttamaan merkkijonon loppuosa tai kaksiparametrisena palauttamaan parametrien valitsema osajono merkkijonosta: </p>
<pre class="sh_java">
String kirja = "Kalavale";

System.out.println(kirja.substring(4)); //tulostaa "vale"
System.out.println(kirja.substring(2,6)); //tulostaa "lava"
</pre>
  <p>Koska <code>substring</code>-metodin <em>paluuarvo</em> on <code>String</code>-tyyppinen,
    voidaan metodin paluuarvo ottaa talteen String-tyyppiseen muuttujaan kirja.. </p>
<pre class="sh_java">
String kirja = "8 veljestä";

String loppuosa = kirja.substring(2);
System.out.println("7 " + loppuosa); // tulostaa: 7 veljestä
</pre>
  <p> String-luokan metodit tarjoavat myös mahdollisuuden etsiä tekstistä tiettyä sanaa.
    Esimerkiksi sana "erkki" sisältyy tekstiin "merkki". 
    Metodi <code>indexOf()</code> etsii parametrinaan annettua sanaa merkkijonosta.
    Jos sana löytyi, se palauttaa sanan ensimmäisen kirjaimen indeksin, eli paikan (muista että paikkanumerointi alkaa nollasta!). Jos taas sanaa ei löytynyt merkkijonosta palautetaan arvo -1. </p>
<pre class="sh_java">
String sana = "merkkijono";

int indeksi = sana.indexOf("erkki"); //indeksin arvoksi tulee 1
System.out.println(sana.substring(indeksi)); //tulostetaan "erkkijono"

indeksi = sana.indexOf("jono"); //indeksin arvoksi tulee 6
System.out.println(sana.substring(indeksi)); //tulostetaan "jono"

indeksi = sana.indexOf("kirja"); //sana "kirja" ei sisälly sanaan "merkkijono"
System.out.println(indeksi); //tulostetaan -1
System.out.println(sana.substring(indeksi)); //virhe!
</pre>
  <p>Screencast aiheesta:</p>
  <p><a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=Ax2bhnJxS4Y" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> </p>
  
  
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Alkuosa</h3>
    <p>Tee ohjelma, joka tulostaa sanan alkuosan.
      Ohjelma kysyy käyttäjältä sanan ja alkuosan pituuden.
      Käytä ohjelmassa metodia <code>substring</code>.</p>
<pre>
Anna sana: <font color="red">esimerkki</font>
Alkuosan pituus: <font color="red">4</font>
Tulos: esim
</pre>
<pre>
Anna sana: <font color="red">esimerkki</font>
Alkuosan pituus: <font color="red">7</font>
Tulos: esimerk
</pre>
</div>
<div class="tehtava">
    <h3>Loppuosa</h3>
    <p>Tee ohjelma, joka tulostaa sanan loppuosan.
      Ohjelma kysyy käyttäjältä sanan ja loppuosan pituuden.
      Käytä ohjelmassa merkkijonon metodia <code>substring</code>.</p>
<pre>
Anna sana: <font color="red">esimerkki</font>
Loppuosan pituus: <font color="red">4</font>
Tulos: rkki
</pre>
<pre>
Anna sana: <font color="red">esimerkki</font>
Loppuosan pituus: <font color="red">7</font>
Tulos: imerkki
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Sana sanassa</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä kaksi sanaa.
      Sitten ohjelma kertoo, onko toinen sana
      ensimmäisen sanan osana. Käytä ohjelmassa
      merkkijonon metodia <code>indexOf</code>.</p>
<pre>
Anna 1. sana: <font color="red">suppilovahvero</font>
Anna 2. sana: <font color="red">ilo</font>
Sana 'ilo' on sanan 'suppilovahvero' osana.
</pre>
<pre>
Anna 1. sana: <font color="red">suppilovahvero</font>
Anna 2. sana: <font color="red">suru</font>
Sana 'suru' ei ole sanan 'suppilovahvero' osana.
</pre>
    <p><strong>Huom:</strong> tulosta ohjelmassasi täsmälleen samassa muodossa kuin esimerkissä!</p>
  </div>
  <div class="tehtava">
    <h3>Merkkijonon kääntäminen</h3>
    <p>Tee metodi <code>kaanna</code>, joka kääntää annetun merkkijonon. Käytä metodille seuraavaa runkoa:</p>
<pre class="sh_java">
public static String kaanna(String merkkijono) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    System.out.print("Anna merkkijono: ");
    String merkkijono = lukija.nextLine();
    System.out.println("Väärinpäin: " + kaanna(merkkijono));
}
    </pre>
    <p><b>Vihje: </b>joudut todennäköisesti kokoamaan metodin sisällä käänteisen merkkijonon merkki kerrallaan. Kokoamisessa kannattaa käyttää apuna String-tyyppistä apumuuttujaa. Aluksi apumuuttujan arvo on tyhjä merkkijono. Tämän jälkeen merkkijonon perään laitetaan uusia merkkejä merkki kerrallaan.</p>
<pre>
String apu = "";

// ...
// lisätään merkki apu-nimisen muuttujan perään
apu = apu + merkki;

</pre>
    <p>Ohjelman tulostus:</p>
    <pre>
Anna merkkijono: <font color="red">esimerkki</font>
ikkremise
    </pre>
  </div>
</div>
  <h2>Oliot ja metodit</h2>
  <p>Merkkijonot poikkeavat luonteeltaan hieman esim. kokonaisluvuista. Kokonaisluvut ovat "pelkkiä arvoja", niiden avulla voi laskea ja niitä voi tulostella ruudulle:</p>
  <pre class="sh_java">
int x = 1;
int y = 3;

y = 3*x + 2;

System.out.println( "y:n arvo nyt: " + y );
  </pre>
  <p>Merkkijonot ovat hieman "älykkäämpiä" ja tietävät esimerkiksi pituutensa:</p>
  <pre class="sh_java">
String sana1 = "Ohjelmointi";
String sana2 = "Java";

System.out.println( "merkkijonon "+ sana1 +" pituus: " + sana1.length() );

System.out.println( "merkkijonon "+ sana2 +" pituus: " + sana2.length() );
  </pre>
  <p>Tulostuu:</p>
  <pre>
merkkijonon Ohjelmointi pituus on 11
merkkijonon Java pituus on 4
</pre>
  <p>Pituus saadaan selville kutsumalla merkkijonon metodia <code>length()</code>. Merkkijonoilla on joukko muitakin metodeja. Kokonaisluvuilla eli <code>int</code>:eillä ei ole metodeja ollenkaan, ne eivät itsessään "osaa" mitään.</p>
  <p>Merkkijonot ovat <em>olioita</em> eli "asioita joihin liittyy metodeja sekä arvo". Jatkossa tulemme näkemään hyvin paljon muitakin olioita kuin merkkijonoja.</p>
  <p>Kuten edellisestä esimerkistä huomaamme, kutsutaan olion metodia lisäämällä olion nimen perään piste ja metodikutsu:</p>
  <pre class="sh_java">
sana1.length()    // kutsutaan merkkijono-olion sana1 metodia length()
sana2.length()    // kutsutaan merkkijono-olion sana2 metodia length()
</pre>
  <p>Metodikutsu kohdistuu nimenomaan sihen olioon, mille metodia kutsutaan. Yllä kutsumme ensin <code>sana1</code>-nimisen merkkijonon <code>length()</code>-metodia, sitten merkkijonon <code>sana2</code> metodia <code>length()</code>.</p>
  <p>Vanha tuttumme <code>lukija</code> on myös olio:</p>
<pre class="sh_java">
Scanner lukija = new Scanner(System.in);
</pre>
  <p>Lukijat ja merkkijonot ovat molemmat oliota, ne ovat kuitenkin varsin erilaisia. Lukijoilla on mm. metodi <code>nextLine()</code> jota merkkijonoilla ei ole. Javassa oliot "synnytetään" eli luodaan melkein aina komennolla <code>new</code>, merkkijonot muodostavat tässä suhteessa poikkeuksen! -- Merkkijonoja voi luoda kahdella tavalla:</p>
<pre class="sh_java">
String banaani = new String("Banaani");
String porkkana = "porkkana";
</pre>
  <p>Kumpikin ylläolevista riveistä luo uuden merkkijono-olion. Merkkijonojen luonnissa <code>new</code>-komentoa käytetään hyvin harvoin.</p>
  <p>Olion "tyyppiä" sanotaan <em>luokaksi</em>. Merkkijonojen luokka on <code>String</code>, lukijoiden luokka taas on <code>Scanner</code>. Opimme jatkossa luokista ja olioista paljon lisää.</p>
  <h2>ArrayList eli "oliosäiliö"</h2>
  <p>Ohjelmoidessa tulee usein vastaan tilanteita joissa haluaisimme pitää muistissa esimerkiksi useita erilaisia merkkijonoja. Todella huono tapa olisi määritellä jokaiselle oma muuttujansa:</p>
<pre class="sh_java">
String sana1;
String sana2;
String sana3;
// ...
String sana10;
</pre>
  <p>Tämä olisi aivan kelvoton ratkaisu ja sen huonoutta ei kannata oikeastaan edes perustella -- ajattele ylläoleva esimerkki vaikkapa sadalla tai tuhannella sanalla.</p>
  <p>Java, kuten kaikki modernit ohjelmointikielet, tarjoaa erilaisia apuvälineitä joiden avulla on helppo säilyttää ohjelmassa monia olioita. Tutustumme nyt Javan ehkä eniten käytettyyn oliosäiliöön <em>ArrayList</em>:iin.</p>
  <p>Seuraava ohjelmanpätkä ottaa käyttöönsä merkkijono-olioita tallentavan ArrayList:in sekä tallettaa listalle pari merkkijonoa.</p>
<pre class="sh_java">
import java.util.ArrayList;

public class ListaOhjelma {

    public static void main(String[] args) {
        ArrayList&lt;String&gt; sanaLista = new ArrayList&lt;String&gt;();

        sanaLista.add("Ensimmäinen");
        sanaLista.add("Toinen");
    }
}
</pre>
  <p>Yllä olevan pääohjelman ensimmäinen rivi luo <code>sanaLista</code>-nimisen merkkijonoja tallettavan arraylistin.  Listamuuttujan tyypin nimi on <code>ArrayList&lt;String&gt;</code>, eli merkkijonoja tallettava ArrayList. Itse lista luodaan sanomalla <code>new ArrayList&lt;String&gt;();</code>. </p>
  <p><b>Huom:</b> Jotta ArrayList toimisi, on ohjelman ylälaitaan kirjoitettava <code>import java.util.ArrayList;</code> tai <code>import java.util.*;</code></p>
  <p>Kun lista on luotu, siihen lisätään kaksi merkkijonoa kutsumalla listan metodia <code>add</code>.  Tila ei lopu listalla missään vaiheessa kesken, eli periaatteessa listalle saa lisätä niin monta merkkijonoa kun "koneen" muistiin mahtuu.</p>
  <p>Sisäisesti ArrayList on nimensä mukaisesti lista. Lisätyt merkkijonot menevät automaattisesti ArrayList:in loppuun.</p>
  <h3>ArrayList:in metodeja</h3>
  <p>ArrayList tarjoaa monia hyödyllisiä metodeita:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Arto");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");
    opettajat.add("Matti");

    System.out.println("opettajien lukumäärä " + opettajat.size() );

    System.out.println("listalla ensimmäisenä " + opettajat.get(0));
    System.out.println("listalla kolmantena " + opettajat.get(2));

    opettajat.remove("Arto");

    if ( opettajat.contains("Arto") ) {
        System.out.println("Arto on opettajien listalla");
    } else {
        System.out.println("Arto ei ole opettajien listalla");
    }
}
</pre>
  <p>Ensin luodaan merkkijonolista jolle lisätään 6 nimeä. <code>size</code> kertoo listalla olevien merkkijonojen lukumäärän. <b>Huom:</b> kun metodia kutsutaan, on kutsu muotoa <code>opettajat.size()</code>, eli metodin nimeä edeltää piste ja sen listan nimi kenen metodia kutsutaan.</p>
  <p>Merkkijonot ovat listalla siinä järjestyksessä missä ne listalle laitettiin. Metodilla <code>get(i)</code> saadaan tietoon listan paikan <code>i</code> sisältö. Listan alkioiden paikkanumerointi alkaa nollasta, eli ensimmäisenä lisätty on paikassa numero 0, toisen a lisätty paikassa numero 1 jne.</p>
  <p>Metodin <code>remove</code> avulla voidaan listalta poistaa merkkijonoja. Jos käytetään metodia muodossa <code>remove("merkkejä")</code>, poistetaan parametrina annettu merkkijono. Metodia voi käyttää myös siten, että annetaan parametriksi tietty luku. Esim. jos sanotaan <code>remove(3)</code> poistuu listalla neljäntenä oleva merkkijono.</p>
  <p>Esimerkin lopussa kutsutaan metodia <code>contains</code> jonka avulla kysytään listalta sisältääkö se parametrina annettavan merkkijonon. Jos sisältää, palauttaa metodi arvon <code>true</code>. </p>
  <p>Ohjelman tulostus:</p>
<pre>
opettajien lukumäärä 6
listalla ensimmäisena Antti
listalla kolmantena Pekka
Arto ei ole opettajien listalla
</pre>
  <p><strong>Huom!</strong> Metodit <code>remove</code> ja <code>contains</code> olettavat että listaan tallennetuilla olioilla on metodi <code>equals</code>. Palaamme tähän myöhemmin kurssilla.</p>
  <h3>ArrayList:in läpikäynti</h3>
  <p>Seuraavassa esimerkissä lisätään listalle 4 nimeä ja tulostetaan listan sisältö:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");

    System.out.println( opettajat.get(0) );
    System.out.println( opettajat.get(1) );
    System.out.println( opettajat.get(2) );
    System.out.println( opettajat.get(3) );
}
</pre>
  <p>Ratkaisu on kuitenkin erittäin kömpelö. Entäs jos listalla olisi enemmän alkiota? Tai vähemmän? Entäs jos ei olisi edes tiedossa listalla olevien alkioiden määrää?</p>
  <p>Tehdään ensin välivaiheen versio jossa pidetään:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");
    opettajat.add("Matti");

    int paikka = 0;
    System.out.println( opettajat.get(paikka) );
    paikka++;
    System.out.println( opettajat.get(paikka) );  // paikka = 1
    paikka++;
    System.out.println( opettajat.get(paikka) );  // paikka = 2
    paikka++;
    System.out.println( opettajat.get(paikka) );  // paikka = 3
}
</pre>
  <p>Vanhan tutun <code>while</code>-komennon avulla voimme kasvataa muuttujaa <code>paikka</code> niin kauan kunnes se kasvaa liian suureksi:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");
    opettajat.add("Matti");

    int paikka = 0;
    while ( paikka &lt; opettajat.size() )  // muistatko miksi paikka &lt;= opettajat.size() ei toimi?
        System.out.println( opettajat.get(paikka) );
        paikka++;
    }
}
</pre>
  <p>Nyt tulostus toimii riippumatta listalla olevien alkioiden määrästä.</p>
  <p>While-toistolauseen käyttö ja listan paikkojen "indeksointi" ei kuitenkaan ole yleensä järkevin tapa listan läpikäyntiin. Suositeltavampi on seuraavassa esiteltävä for-each -toistolauseke.</p>
  <h3>for-each</h3>
  <p>Vaikka komennosta käytetään nimitystä for-each, komennon nimi on pelkästään <code>for</code>.
    for:ista on olemassa kaksi versiota, perinteinen (jonka nopea esittely oli jo viimeviikolla mutta mitä alame varsinaisesti käyttämään vasta viikolla 6) ja "for-each" jota käytämme nyt.</p>
  <p>ArrayList:in alkioiden läpikäynti for-each:illa on lasten leikkiä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");
    opettajat.add("Matti");

    for (String opettaja : opettajat) {
        System.out.println( opettaja );
    }
}
</pre>
  <p>Kuten huomaame, ei listalla olevien merkkijonojen paikkanumeroista tarvitse välittää, for käy listan sisällön läpi "automaattisesti".
  </p>
<p>Komennon for aaltosulkujen sisällä olevassa koodissa käytetään muuttujaa <code>opettaja</code>, joka on määritelty for-rivillä kaksoispisteen vasemmalla puolella. Käy niin, että kukin listalla <code>opettajat</code> oleva merkkijono tulee vuorollaan muuttujan <code>opettaja</code> arvoksi. Eli kun for:iin mennään, on <code>opettaja</code> ensin <em>Antti</em>, forin toisella toistolla <code>opettaja</code> on <em>Pekka</em>, jne </p>
  <p>Vaikka <code>for</code>-komento voi tuntua aluksi hieman oudolta sitä kannattaa ehdottomasti totutella käyttämään!</p>
  <p>Screencast aiheesta:</p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=-y67VJ68Izs" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"></a> 

  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Sanat</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä sanoja, kunnes käyttäjä antaa tyhjän merkkijonon. Sitten ohjelma tulostaa käyttäjän antamat
      sanat uudestaan. <em>Kokeile tässä for-toistolauseketta</em>. Käytä ohjelmassa <code>ArrayList</code>-rakennetta, joka määritellään seuraavasti:</p>
<pre class="sh_java">
ArrayList&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
</pre>
<pre>
Anna sana: <font color="red">Mozart</font>
Anna sana: <font color="red">Schubert</font>
Anna sana: <font color="red">Bach</font>
Anna sana: <font color="red">Sibelius</font>
Anna sana: <font color="red">Liszt</font>
Anna sana:
Annoit seuraavat sanat:
Mozart
Schubert
Bach
Sibelius
Liszt
</pre>
    <p><b>Vihje:</b> tyhjä merkkijono voidaan havaita seuraavasti
    </p>
<pre class="sh_java">
String sana = lukija.nextLine();

if ( sana.isEmpty() ) {  // myös tämä tomisi: sana.equals("")
    // sana oli tyhjä eli pelkkä enterin painallus
}
</pre>
    
  </div>
  <div class="tehtava">
    <h3 class="req">Toistuva sana</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä sanoja, kunnes käyttäjä antaa saman sanan uudestaan.
      Käytä ohjelmassa <code>ArrayList</code>-rakennetta, joka määritellään seuraavasti:</p>
<pre class="sh_java">
ArrayList&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
</pre>
    <p>Kun sama sana toistuu, ilmoittaa ohjelma asiasta seuraavasti:</p>
<pre>
Anna sana: <font color="red">porkkana</font>
Anna sana: <font color="red">selleri</font>
Anna sana: <font color="red">nauris</font>
Anna sana: <font color="red">lanttu</font>
Anna sana: <font color="red">selleri</font>
Annoit uudestaan sanan selleri
</pre>
    <p><b>Vihje: </b> Muista arraylistin metodi <code>.contains()</code></p>
  </div>
</div>
  <h3>Listan järjestäminen, kääntäminen ja sekoittaminen</h3>
  <p>ArrayList:n sisältö on helppo järjestää suuruusjärjestykseen. Suuruusjärjestys merkkijonojen yhteydessä tarkoittaa aakkosjärjestystä. Järjestäminen tapahtuu seuraavasti:</p>
<pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    // ...

    Collections.sort(opettajat);

    for (String opettaja : opettajat) {
        System.out.println( opettaja );
    }
}
</pre>
  <p>Tulostuu:</p>
<pre>
Antti
Arto
Juhana
Martin
Matti
Pekka
</pre>
  <p>Annetaan siis lista parametriksi metodille <code>Collections.sort</code>. Jotta Collections:in apuvälineet toimisivat, on ohjelman yläosassa oltava <code>import java.util.Collections;</code> tai <code>import java.util.*;</code></p>
  <p>Collections:ista löytyy muutakin hyödyllistä:</p>
  <ul>
<li> <code>shuffle</code> sekoittaa listan sisällön, metodista voi olla hyötyä esimerkiksi peleissä</li>
    <li> <code>reverse</code> kääntää listan sisällön</li>
  </ul>
<div class="tehtavat">
  <div class="tehtava">
    <h3 class="req">Sanat käänteisesti</h3>
    <p> Tee ohjelma, joka kysyy käyttäjältä sanoja, kunnes käyttäjä antaa tyhjän merkkijonon.
      Sitten ohjelma tulostaa käyttäjän antamat sanat päinvastaisessa järjestyksessä, eli viimeinen syötetty sana ensin jne.</p>
<pre>
Anna sana: <font color="red">Mozart</font>
Anna sana: <font color="red">Schubert</font>
Anna sana: <font color="red">Bach</font>
Anna sana: <font color="red">Sibelius</font>
Anna sana: <font color="red">Liszt</font>
Anna sana:
Annoit seuraavat sanat:
Liszt
Sibelius
Bach
Schubert
Mozart
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Sanat aakkosjärjestyksessä</h3>
    <p>Tee edellistä tehtävää vastaava ohjelma,
      jossa sanat tulostetaan aakkosjärjestyksessä.</p>
<pre>
Anna sana: <font color="red">Mozart</font>
Anna sana: <font color="red">Schubert</font>
Anna sana: <font color="red">Bach</font>
Anna sana: <font color="red">Sibelius</font>
Anna sana: <font color="red">Liszt</font>
Anna sana:
Annoit seuraavat sanat:
Bach
Liszt
Mozart
Schubert
Sibelius
</pre>
  </div>
  </div>
  <h3>ArrayList metodin parametrina</h3>
  <p>ArrayList:in voi antaa metodille parametrina:</p>
  <pre class="sh_java">
public static void tulosta(ArrayList&lt;String&gt; lista) {
    for (String sana : lista) {
        System.out.println( sana );
    }
}

public static void main(String[] args) {
    ArrayList&lt;String&gt; lista = new ArrayList&lt;String&gt;();
    lista.add("Java");
    lista.add("Python");
    lista.add("Ruby");
    lista.add("C++");

    tulosta(lista);
}
</pre>
  <p>Parametrin tyyppi siis määritellään listaksi täsmälleen samalla tavalla eli <code>ArrayList&lt;String&gt;</code> kuin listamuuttujan määrittely tapahtuu.</p>
  <p>Huomaa, että parametrin nimellä ei ole merkitystä:</p>
<pre class="sh_java">
public static void tulosta(ArrayList&lt;String&gt; tulostettava) {
    for (String sana : tulostettava) {
        System.out.println( sana );
    }
}

public static void main(String[] args) {
    ArrayList&lt;String&gt; ohjelmointikielet = new ArrayList&lt;String&gt;();
    ohjelmointikielet.add("Java");
    ohjelmointikielet.add("Python");
    ohjelmointikielet.add("Ruby");
    ohjelmointikielet.add("C++");

    ArrayList&lt;String&gt; maat = new ArrayList&lt;String&gt;();
    maat.add("Suomi");
    maat.add("Ruotsi");
    maat.add("Norja");

    tulosta(ohjelmointikielet);    // annetaan metodille parametriksi lista ohjelmointikielet

    tulosta(maat);                 // annetaan metodille parametriksi lista maat
}
</pre>
  <p>Ohjelmassa on nyt kaksi listaa <em>ohjelmointikielet</em> ja <em>maat</em>. Metodille annetaan ensin tulostettavaksi lista <em>ohjelmointikielet</em>. Metodi <code>tulosta</code> käyttää parametriksi saamastaan listasta sisäisesti nimellä <em>tulostettava</em>! Seuraavaksi metodille annetaan tulostettavaksi lista <em>maat</em>. Jälleen metodi käyttää parametrinaan saamasta listasta sisäisesti nimeä <em>tulostettava</em>. </p>
  <div class="tehtavat">
  <div class="tehtava">
    <h3 class="req">Listan alkioiden lukumäärä</h3>
    <p>Tee metodi <code>public static int
      laskeAlkiot(ArrayList&lt;String&gt; lista)</code> joka palauttaa listan alkioiden määrän. Metodisi ei siis tulosta mitään vaan
      palauttaa <code>return</code>:illa alkioiden lukumäärän seuraavan esimerkin mukaisesti</p>
<pre class="sh_java">
ArrayList&lt;String&gt; lista = new ArrayList&lt;String&gt;();
lista.add("Moi");
lista.add("Ciao");
lista.add("Hello");
System.out.println("Listalla on alkioita:");
System.out.println(laskeAlkiot(lista));
</pre>
<pre>
Listalla on alkioita:
3
</pre>
</div>
</div>
  <p>Metodin sisällä on mahdollisuus vaikuttaa parametrina saadun listan sisältöön. Seuraavassa esimerkissä metodi <code>poistaEnsimmainen</code> nimensä mukaisesti poistaa listalla ensimmäisenä olevan merkkijonon (mitähän tapahtuu jos listalla ei ole mitään?).</p>
  <pre class="sh_java">
public static void tulosta(ArrayList&lt;String&gt; tulostettava) {
    for (String sana : tulostettava) {
        System.out.println( sana );
    }
}

public static void poistaEnsimmainen(ArrayList&lt;String&gt; lista) {
    lista.remove(0);  // poistetaan listalta ensimmäinen eli "nollas"
}

public static void main(String[] args) {
    ArrayList&lt;String&gt; ohjelmointikielet = new ArrayList&lt;String&gt;();
    ohjelmointikielet.add("Pascal");
    ohjelmointikielet.add("Java");
    ohjelmointikielet.add("Python");
    ohjelmointikielet.add("Ruby");
    ohjelmointikielet.add("C++");


    tulosta(ohjelmointikielet);

    poistaEnsimmainen(ohjelmointikielet);

    System.out.println();  // tulostetaan tyhjä rivi

    tulosta(ohjelmointikielet);
}
</pre>
<p>Tulostuu:</p>
<pre>
Pascal
Java
Python
Ruby
C++

Java
Python
Ruby
C++
</pre>
  <p>Vastaavalla tavalla metodi voisi esim. lisätä parametrina saamaansa listaan lisää merkkijonoja.</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Poista viimeinen</h3>
    <p>Tee metodi <code>public static void poistaViimeinen(ArrayList&lt;String&gt;
      lista)</code> joka poistaa listalla viimeisenä olevan alkion. Tällöin
      esimerkiksi seuraava koodi:</p>
<pre class="sh_java">
ArrayList&lt;String&gt; tyypit = new ArrayList&lt;String&gt;();
tyypit.add("Pekka");
tyypit.add("Mauri");
tyypit.add("Jore");
tyypit.add("Simppa");

System.out.println("Tyypit:");
System.out.println(tyypit);

// tyypit järjestykseen!
tyypit.sort();

// heitetään viimeinen mäkeen!
poistaViimeinen(tyypit);

System.out.println(tyypit);
</pre>
<p>Tulostaa:</p>
<pre>
Tyypit:
[Pekka, Mauri, Jore, Simppa]
[Jore, Mauri, Pekka]
</pre>
</div>
</div>
  <p>Kuten edellisen tehtävän esimerkkitulostuksesta näemme, voi ArrayList:in tulostaa sellaisenaan. Tulostusmuoto ei kuitenkaan yleensä ole halutun kaltainen ja tulostus joudutaan hoitamaan itse esim. <code>for</code>-komennon avulla.</p>
  <h3>Lukuja ArrayList:issä</h3>
  <p>ArrayList:eihin voi tallettaa minkä tahansa tyyppisiä arvoja. Jos talletetaan kokonaislukuja eli <code>int</code>:ejä, tulee muistaa pari detaljia. int:ejä tallettava lista tulee määritellä <code>ArrayList&lt;Integer&gt;</code>, eli <code>int</code>:n sijaan tulee kirjoittaa <code>Integer</code>. </p>
  <p>Kun listalle talletetaan <code>int</code>-lukuja, ei metodi <code>remove</code> toimi aivan odotetulla tavalla:
  </p>
<pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();

    luvut.add(4);
    luvut.add(8);

    // yrittää poistaa luvun listan kohdasta 4, eli ei toimi odotetulla tavalla!
    luvut.remove(4);

    // tämä poistaa listalta luvun 4
    luvut.remove( Integer.valueOf(4) );
}
</pre>
  <p>Eli <code>luvut.remove(4)</code> yrittää poistaa listalla kohdassa 4 olevan alkion. Listalla on vain 2 alkiota, joten komento aiheuttaa virheen. Jos halutaan poistaa luku 4, täytyy käyttää hieman monimutkaisempaa muotoa: <code>luvut.remove( Integer.valueOf(4) );</code></p>
  <p>Listalle voi tallettaa myös liukulukuja eli <code>double</code>:ja ja merkkejä eli <code>char</code>:eja. Tällöin listat luodaan seuraavasti:</p>
  <pre class="sh_java">
ArrayList&lt;Double&gt; doublet = new ArrayList&lt;Double&gt;();
ArrayList&lt;Character&gt; merkit = new ArrayList&lt;Character&gt;();
    </pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Lukujen summa</h3>
    <p>Tee metodi <code>summa</code>, joka laskee parametrinaan saamansa kokonaislukuja sisältävän, eli tyyppiä <code>ArrayList&lt;Integer&gt;</code> olevan listan summan.</p>
    <p>Tee metodi seuraavaan runkoon:</p>
<pre class="sh_java">
public static int summa(ArrayList&lt;Integer&gt; lista) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Summa: " + summa(lista));

    lista.add(10);

    System.out.println("Summa: " + summa(lista));
}
  </pre>
    <p>Ohjelman tulostus:</p>
<pre>
Summa: 14
Summa: 24
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Lukujen keskiarvo</h3>
    <p>Tee metodi <code>keskiarvo</code>, joka laskee parametrinaan saamansa kokonaislukuja sisältävän listan lukujen keskiarvon. Metodin on laskettava parametriensa summa käyttäen apuna edellisen tehtävän metodia <code>summa</code>.</p>
    <p>Tee metodi seuraavaan runkoon:</p>
    <pre class="sh_java">
public static double keskiarvo(ArrayList&lt;Integer&gt; lista) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Keskiarvo: " + keskiarvo(lista));
}
</pre>
    <p>Ohjelman tulostus:</p>
    <pre>
Keskiarvo: 3.5
</pre>
  </div>
  <div class="tehtava">
    <h3>Suurin</h3>
    <p>Tee metodi <code>suurin</code>, joka palauttaa parametrina saamansa kokonaislukuja sisältävän listan suurimman luvun.</p>
    <pre class="sh_java">
public static int suurin(ArrayList&lt;Integer&gt; lista) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Suurin: " + suurin(lista));
}
</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Suurin: 7
</pre>
</div>
<div class="tehtava">
    <h3>Varianssi</h3>
    <p>Tee metodi <code>varianssi</code>, joka laskee palauttaa saamansa kokonaislukuja sisältävän listan otosvarianssin.
      Ohjeen varianssin laskemiseksi voit katsoa esimerkiksi <a href="http://fi.wikipedia.org/wiki/Varianssi#Populaatio-_ja_otosvarianssi">Wikipediasta</a> kohdasta populaatio- ja otosvarianssi.</p>
    <p> Tee metodi käytäen apuna tehtävän 64 metodia <code>keskiarvo</code>, kutsu metodia kuitenkin vain kertaalleen yhden varianssin laskemisen aikana. </p>
    <pre class="sh_java">
public static double varianssi(ArrayList&lt;Integer&gt; lista) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Varianssi: " + varianssi(lista));
}
</pre>
    <p>Ohjelman tulostus:</p>
    <pre>
  Varianssi: 5.666667
</pre>
    <p>(Lukujen keskiarvo on 3.5, joten otosvarianssi on
      ((3 - 3.5)² + (2 - 3.5)² + (7 - 3.5)² + (2 - 3.5)²)/(4 - 1) ≈ 5,666667.) </p>
    <p><strong>Huom!</strong> Muistathan kokeillessasi ohjelmaa, että
      yhden alkion kokoisen listan (otos)varianssia ei ole määritelty!
      Kaavassa tapahtuu tällöin nollalla jakaminen. Java esittää
      nollalla jakamisen tuloksen <em>epänumerona</em> <code>NaN</code></p>
  </div>
</div>
  <h2>Totuusarvojen käyttö</h2>
  <p>Totuusarvoinen eli <code>boolean</code>-muuttuja voi saada vain kaksi arvoa <em>true</em> tai <em>false</em>. Seuraavassa esimerkki booleanin käytöstä:</p>
  <pre class="sh_java">
int luku1 = 1;
int luku2 = 5;

boolean ekaSuurempi = true;

if (luku1 &lt;= luku2) {
    ekaSuurempi = false;
}

if (ekaSuurempi==true) {
    System.out.println("luku1 suurempi");
} else {
    System.out.println("luku1 ei ollut suurempi");
}
</pre>
  <p>Eli ensin asetetaan totuusarvon <code>ekaSuurempi</code> arvoksi tosi eli <em>true</em>. Ensimmäinen if tarkastaa onko <code>luku1</code> pienempi tai yhtä pieni kuin <code>luku2</code>. Jos näin on, vaihdetaan totuusarvon arvoksi epätosi eli <em>false</em>. Myöhempi if valitsee tulostuksen totuusarvoon perustuen.</p>
  <p>Totuusarvon käyttö ehtolauseessa on itseasiassa edellistä esimerkkiä yksinkertaisempaa, jälkimmäinen if voidaan kirjoittaa seuraavasti:</p>
  <pre class="sh_java">
if (ekaSuurempi) {  // tarkoittaa samaa kuin ekaSuurempi==true
    System.out.println("luku1 suurempi");
} else {
    System.out.println("luku1 ei ollut suurempi");
}
</pre>
  <p>Eli jos halutaan tarkistaa että booleanmuuttujan arvo on tosi, eli ole tarvetta kirjoittaa <code>==true</code>, pelkkä muuttujan nimi riittää!</p>
  <p>Epätoden tarkastaminen onnistuu negaatio-operaation eli huutomerkin avulla:</p>
  <pre class="sh_java">
if (!ekaSuurempi) {  // tarkoittaa samaa kuin ekaSuurempi==false
    System.out.println("luku1 ei ollut suurempi");
} else {
    System.out.println("luku1 suurempi");
}
</pre>
  <h3>totuusarvon palauttava metodi</h3>
  <p>Totuusarvot ovat erityisen käteviä jonkun asian voimassaolon tarkistavien metodien paluuarvoina. Tehdään metodi joka tarkastaa sisältääkö sen parametrina saama lista ainoastaan positiivisia lukuja (tulkitaan 0 positiiviseksi). Tieto positiivisuudesta palautetaan totuusarvona.</p>
  <pre class="sh_java">
public static boolean kaikkiPositiivisia(ArrayList&lt;Integer&gt; luvut) {
    boolean eiNegatiivisia = true;

    for (int luku : luvut) {
        if (luku &lt; 0) {
            eiNegatiivisia = false;
        }
    }
    // jos jonkun listan luvuista arvo oli pienempi kuin 0, on eiNegatiivisia nyt false
    return eiNegatiivisia;
}
</pre>
  <p>Metodilla on totuusarvoinen apumuuttuja <code>eiNegatiivisia</code>. Apumuuttujan arvoksi asetetaan ensin true. Metodi käy läpi kaikki listan luvut. Jos jonkun (siis vähintään yhden) luvun arvo on pienempi kuin nolla, asetetaan apumuuttujan arvoksi false. Lopuksi palautetaan apumuuttujan arvo. Apumuuttuja on edelleen true jos yhtään negatiivista lukua ei löytynyt, muuten false.</p>
  <p>Metodia käytetään seuraavasti:</p>
  <pre class="sh_java">
public static void main(String[] args) {

    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
    luvut.add(3);
    luvut.add(1);
    luvut.add(-1);

    boolean vastaus = kaikkiPositiivisia(luvut);

    if (vastaus) {  // tarkoittaa siis samaa kuin vastaus == true
        System.out.println("luvut positiivisia");
    } else {
        System.out.println("joukossa oli ainakin yksi negatiivinen");
    }
}
</pre>
  <p>Vastauksen tallettaminen ensin muuttujaan ei yleensä ole tarpeen, ja metodikutsu voidaan kirjottaa suoraan ehdoksi:</p>
  <pre class="sh_java">
ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
luvut.add(4);
luvut.add(7);
luvut.add(12);
luvut.add(9);

if (kaikkiPositiivisia(luvut)) {
    System.out.println("luvut positiivisia");
} else {
    System.out.println("joukossa oli ainakin yksi negatiivinen");
}

</pre>
  <h3>Komento return ja metodin lopetus</h3>
  <p>Metodin suoritus loppuu välittömästi kun metodissa suoritetaan <code>return</code>-käsky. Käyttämällä tätä tietoa hyväksi voimme kirjoittaa <code>kaikkiPositiivisia</code>-metodin
    hiukan suoraviivaisemmin ja selkeämmin. </p>
  <pre class="sh_java">
public static boolean kaikkiPositiivisia(ArrayList&lt;Integer&gt; luvut) {
    for (int luku : luvut) {
        if (luku &lt; 0) {
            return false;
        }
    }

    // jos tultiin tänne asti, ei yhtään negatiivista löytynyt
    // siispä palautetaan true
    return true;
    }
}
</pre>
  <p>Eli jos lukujen listaa läpikäydessä törmätään negatiiviseen lukuun, voidaan metodista poistua heti palauttamalla false. Jos listalla ei ole yhtään negatiivista, päädytään loppuun ja voidaan palauttaa true. Olemme päässeet metodissa kokonaan eroon apumuuttujan käytöstä!</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Onko luku listalla monta kertaa</h3>
    <p>Tee metodi <code>onkoListallaUseasti</code>, joka saa parametrinaan
      kokonaislukuja sisältävän listan ja int-luvun. Jos luku esiintyy
      listalla <em>yli yhden kerran</em>, metodi
      palauttaa <code>true</code> ja muulloin <code>false</code>.</p>
    <p>Ohjelman rakenne on seuraava:</p>
    <pre class="sh_java">
public static boolean onkoListallaUseasti(ArrayList&lt;Integer&gt; lista, int luku) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Anna luku: ");
    int luku = Integer.parseInt(lukija.nextLine());
    if (onkoListallaUseasti(luvut, luku)) {
        System.out.println(luku + " on listalla useasti.");
    } else {
        System.out.println(luku + " ei ole listalla useasti.");
    }
}
</pre>
    <pre>
  Anna luku: <font color="red">2</font>
  Luku on on listalla useasti.
</pre>
    <pre>
  Anna luku: <font color="red">3</font>
  Luku ei ole listalla useasti.
</pre>
</div>
<div class="tehtava">
    <h3>Palindromi</h3>
    <p>Tee metodi <code>palindromi</code>, joka kertoo, onko merkkijono palindromi (merkkijonon sisältö on sama alusta loppuun ja lopusta alkuun luettuna).</p>
    <p>Metodi voi käyttää apuna metodia <code>kaanna</code> tehtävästä 56. Metodin tyyppi on <code>boolean</code>, joten se pa lauttaa jokoarvon <code>true</code> (merkkijono on palindromi) tai <code>false</code> (merkkijono ei ole palindromi).</p>
    <pre class="sh_java">
public static boolean palindromi(String merkkijono) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    System.out.println("Anna merkkijono: ");
    String merkkijono = lukija.nextLine();
    if (palindromi(merkkijono)) {
        System.out.println("Merkkijono on palindromi!");
    } else {
        System.out.println("Merkkijono ei ole palindromi!");
    }
}
</pre>
    <p>Ohjelman tulostuksia:</p>
<pre>
Anna merkkijono: <font color="red">saippuakauppias</font>
Merkkijono on palindromi!
</pre>
<pre>
Anna merkkijono: <font color="red">esimerkki</font>
Merkkijono ei ole palindromi!
</pre>
</div>
  </div>
  <h3>ArrayListin kopioiminen</h3>
  <p>Joskus on tarpeen muodostaa ArrayLististä kopio, johon voi tehdä muutoksia vaikuttamatta alkuperäisen ArrayListin sisältöön. Kopion voi muodostaa luomalla uuden ArrayListin käyttäen vanhaa ArrayListiä parametrina:</p>
<pre class="sh_java">
ArrayList&lt;String&gt; nimet = new ArrayList&lt;String&gt;();
nimet.add("Kyösti");
nimet.add("Risto");
nimet.add("Carl");
nimet.add("Urho");

//luodaan kopio nimet-listasta
ArrayList&lt;String&gt; kopio = new ArrayList&lt;String&gt;(nimet);
//järjestetään kopio
Collections.sort(kopio);

System.out.println(kopio);  //tulostuu [Carl, Kyösti, Risto, Urho]
System.out.println(nimet);  //tulostuu [Kyösti, Risto, Carl, Urho]
</pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3>KaikkiEri</h3>
    <p>Tee metodi <code>kaikkiEri</code>, joka palauttaa true jos sen parametrina saamassa kokonaislukuja sisältävässä listassa olevat luvut ovat kaikki erisuuruisia. Metodi ei saa muuttaa listan sisältöä.</p>
    
    <p>Seuraavassa kaksi esimerkkiä metodin toiminnasta:</p>
    <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista1 = new ArrayList&lt;Integer&gt;();
    lista1.add(3);
    lista1.add(7);
    lista1.add(1);

    boolean eri = kaikkiEri(lista1);
    // muuttujan eri arvo true

    ArrayList&lt;Integer&gt; lista2 = new ArrayList&lt;Integer&gt;();
    lista2.add(2);
    lista2.add(3);
    lista2.add(7);
    lista2.add(1);
    lista2.add(3);
    lista2.add(99);

    eri = kaikkiEri(lista2);
    // muuttujan eri arvo false sillä luku 3 on listalla kahteen kertaan
}
</pre>
</div>
  </div>
  <h2>Metodit ja parametrien kopioituminen</h2>
  <p>Tarkastellaan muutamaa metodeihin liittyvää tärkeää yksityiskohtaa.</p>
  <p>Luvussa 15 oli esimerkki, jossa yritettiin muuttaa pääohjelmassa olevan muuttujan arvoa metodin sisällä.</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = 1;
    kasvataKolmella();
    System.out.println("luku on " + luku);
}

public static void kasvataKolmella() {
    luku = luku + 3;
}
</pre>
  <p>Ohjelma ei toimi, sillä metodi ei pääse käsiksi pääohjelman muuttujaan <code>luku</code>.</p>
  <p>Tämä johtuu siitä, että pääohjelman muuttujat eivät näy metodien sisään. Ja yleisemmin: minkään metodin muuttujat eivät näy muille metodeille. Koska pääohjelma <code>main</code> on myös metodi, pätee sääntö myös pääohjelmalle. Ainoa keino viedä metodille tietoa ulkopuolelta on parametrin avulla.</p>
  <p>Yritetään korjata edellinen esimerkki välittämällä pääohjelman muuttuja <code>luku</code> parametrina metodille.</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = 1;
    kasvataKolmella(luku);
    System.out.println(luku);  // tulostaa 1, eli arvo luku ei muuttunut
}

public static void kasvataKolmella(int luku) {
    luku = luku + 3;
}
</pre>
  <p>Ohjelma ei toimi toivotulla tavalla. Metodissa olevat parametrit ovat eri muuttujia kuin pääohjelmassa esitellyt muuttujat.  Edellä metodi siis kasvattaa samannimistä, mutta ei samaa parametria <code>luku</code>.</p>
  <p>Kun metodille annetaan parametri, parametrin arvo <em>kopioidaan uuteen muuttujaan</em> metodissa käytettäväksi. Yllä olevassa esimerkissä metodille <code>kasvataKolmella</code> annetusta muuttujasta <code>luku</code> luodaan kopio, jota metodin sisällä lopulta käsitellään.  Metodi käsittelee siis pääohjelmassa olevan muuttujan kopiota, ei alkuperäistä muuttujaa -- pääohjelmametodissa olevalle muuttujalle <code>luku</code> ei tehdä mitään.</p>
  <p>Voidaan ajatella, että pääohjelmametodi <code>main</code> ja metodi <code>kasvataKolmella</code> toimivat kumpikin omassa kohtaa tietokoneen muistia. Allaolevassa kuvassa on <code>main</code>:in muuttujaa <code>luku</code> varten oma "lokero". Kun metodia kutsutaan, tehdään tälle oma muuttuja <code>luku</code> jonka arvoksi kopioituu <code>main</code>:in <code>luku</code>-muuttujan arvo eli 1. Molemmat <code>luku</code>-nimiset muuttujat ovat kuitenkin täysin erillisiä, eli kun metodissa <code>kasvataKolmella</code> muutetaan sen <code>luku</code>-muuttujan arvoa, ei muutos vaikuta millään tavalla pääohjelman muuttujaan <code>luku</code>.</p>
  <p>Allaoleva kuva antaa lisävalaisua tilanteeseen.</p>
  <p> <img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/metodi1.png"></p>
  <p>Metodista saa toki välitettyä tietoa kutsujalle käyttäen paluuarvoa, eli palauttamalla arvon <code>return</code>-komennolla. Edellinen saadaan toimimaan muuttamalla koodia hiukan:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = 1;
    luku = kasvataKolmellaJaPalauta(luku);

    System.out.println(luku);  // tulostaa 4, sillä luku on saanut arvokseen metodin palauttaman arvon
}

public static int kasvataKolmellaJaPalauta(int luku) {
    luku = luku + 3;

    return luku;
}
</pre>
  <p>Edelleen on niin, että metodi käsittelee pääohjelman <code>luku</code>-muuttujan arvon kopiota. Pääohjelmassa metodin palauttama arvo sijoitetaan muuttujaan <code>luku</code>, joten muutos tulee tämän takia voimaan myös pääohjelmassa. Huomaa, että edellisessä ei ole mitään merkitystä sillä, mikä nimi metodin parametrilla on. Koodi toimii täysin samoin oli nimi mikä tahansa, esim. </p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = 1;
    luku = kasvataKolmellaJaPalauta(luku);

    System.out.println(luku);
}

public static int kasvataKolmellaJaPalauta(int kasvatettavaLuku) {
    kasvatettavaLuku = kasvatettavaLuku + 3;

    return kasvatettavaLuku;
}
</pre>
  <p>Huomasimme että metodissa olevat parametrit ovat eri muuttujia kuin metodin kutsujassa esitellyt muuttujat. Ainoastaan parametrin arvo kopioituu kutsujasta metodiin.</p>
  <p>Asia ei kuitenkaan ole ihan näin yksinkertainen. Jos metodille annetaan parametrina <code>ArrayList</code>, käy niin että sama lista näkyy metodille ja kaikki metodin listalle tekemät muutokset tulevat kaikkialla voimaan.</p>
  <pre class="sh_java">
public static void poistaAlussaOleva(ArrayList&lt;Integer&gt; lista) {
    lista.remove(0); // poistaa paikassa 0 olevan luvun
}
</pre>
  <pre class="sh_java">
ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
luvut.add(4);
luvut.add(3);
luvut.add(7);
luvut.add(3);

System.out.println(luvut); // tulostuu [4,3,7,3]

poistaAlussaOleva(luvut);

System.out.println(luvut); // tulostuu [3,7,3]
</pre>
  <p>Toisin kuin <code>int</code>-tyyppinen parametri, lista ei kopioidu vaan metodi käsittelee suoraan parametrina annettua listaa. </p>
  <p>Tilannetta valaisee allaoleva kuva. Toisin kuin <code>int</code>-tyyppinen muuttuja, <code>ArrayList</code> ei sijaitsekaan samalla tapaa "lokerossa", vaan muuttujan nimi, eli mainin tapauksessa <code>luvut</code> onkin ainoastaan <em>viite</em> paikkaan missä <code>ArrayList</code> sijaitsee. Yksi tapa ajatella asiaa, on että <code>ArrayList</code> on "langan päässä", eli listan nimi <code>luvut</code> on lanka jonka toisesta päästä lista löytyy. Kun metodikutsun parametrina on <code>ArrayList</code>, käykin niin että metodille annetaan "lanka" jonka päässä on sama lista jonka metodin kutsuja näkee. Eli main:illa ja metodilla on kyllä molemmilla oma lanka, mutta langan päässä on sama lista ja kaikki muutokset mitä metodi tekee listaan tapahtuvat täsmälleen samaan listaan jota pääohjelma käyttää. Tästä viikosta alkaen tulemme huomaamaan että Java:ssa hyvin moni asia on "langan päässä".</p>
  <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/metodi-lanka.PNG" height="400"></p>
  <p>Huomaa jälleen että parametrin nimi metodin sisällä voi olla aivan vapaasti valittu, nimen ei tarvitse missään tapauksessa olla sama kuin kutsuvassa metodissa oleva nimi. Edellä listaa kutsutaan metodin sisällä nimellä <code>lista</code>, metodin kutsuja taas näkee saman listan <code>luvut</code>-nimisenä.</p>
  <p>Miksi <code>int</code>-parametrista ainoastaan arvo kopioituu metodille mutta parametrin ollessa <code>ArrayList</code> metodi käsittelee suoraan listan sisältöä? Javassa ainoastaan <strong><em>alkeistietotyyppisten</em></strong> eli tyyppien <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code> (ja muutamien muiden joita emme ole käsitelleet) arvot kopioidaan metodille. Muun tyyppisten parametrien tapauksessa metodille kopioidaan <em>viite</em>, ja metodista käsitellään viitteen takana olevaa parametria suoraan. Ei-alkeistyyppiset muuttujat -- eli <strong><em>viittaustyyppiset</em></strong> muuttujat ovat siis edellisen kuvan tapaan "langan päässä" -- metodille välitetään lanka parametriin, ja näin metodi käsittelee parametria suoraan.</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3>ArrayListien yhdistäminen</h3>
    <p>Toteuta metodi <code>public static void yhdista(ArrayList&lt;Integer&gt; eka, ArrayList&lt;Integer&gt; toka)</code>, joka lisää toisena parametrina <code>toka</code> olevassa ArrayListissa olevat luvut ensimmäisenä parametrina olevaan ArrayList:iin <code>eka</code>. Alkioiden talletusjärjestyksellä ei ole väliä, ja sama alkio voi päätyä listalle useamman kerran. Esimerkki metodin toiminnasta:</p>
    <pre class="sh_java">
ArrayList&lt;Integer&gt; lista1= new ArrayList&lt;Integer&gt;();
ArrayList&lt;Integer&gt; lista2= new ArrayList&lt;Integer&gt;();

lista1.add(4);
lista1.add(3);

lista2.add(5);
lista2.add(10);
lista2.add(7);

yhdista(lista1, lista2);

System.out.println(lista1); // tulostuu [4, 3, 5, 10, 7]

System.out.println(lista2); // tulostuu [5, 10, 7]
  </pre>
    <p>Listalle voi lisätä toisen listan sisällön ArrayList-luokan tarjoaman <code>addAll</code>-metodin avulla. Lista saa parametrinä toisen listan, jonka alkiot listalle lisätään.</p>
  </div>
  <div class="tehtava">
    <h3>Joukkoyhdistäminen</h3>
    <p>Toteuta metodi <code>joukkoYhdista</code> joka toimii muuten samoin kuin edellisen tehtävän <code>yhdista</code>-metodi, mutta parantele sitä niin, että yhdistäminen lisää listaan <code>eka</code> lukuja vain, jos ne eivät jo ennestään löydy listalta. Tehtävässä kannattaa käyttää hyväkseen ArrayListin <code>contains</code>-metodia, jolla voit tarkistaa sisältääkö lista jo jonkin luvun.</p>
  </div>
</div>
  <h2>Ohjeita koodin kirjoittamiseen ja ongelmanratkaisuun</h2>
  <p>Yksi maailman johtavista ohjelmistonkehittäjistä, <em>Kent Beck</em>, on lausunut mm. seuraavasti:</p>
  <ul>
<li> <em>"Any fool can write code that a computer can understand.  Good programmers write code that humans can understand."</em> </li>
    <li> <em>"I'm not a great programmer, I'm just good programmer with great habits."</em> </li>
  </ul>
<p>Otamme viimeistään nyt ensimmäisiä askelia Kent Beckin viitoittamalla tiellä.</p>
  <h3>Oikein sisennetty ja "hengittävä" koodi</h3>
  <p>Tarkastellaan koodia joka ensin lisää listalle lukuja ja tulostaa listan sisällön. Tämän jälkeen listalta poistetaan kaikki tietyn luvun esiintymät ja tulostetaan lista uudelleen.</p>
  <p>Kirjoitetaan koodi ensin huonosti ja jätetään se sisentämättä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
luvut.add(4);
luvut.add(3);
luvut.add(7);
luvut.add(3);
System.out.println("luvut alussa:");

for (int luku : luvut) {
System.out.println(luku);
}

while (luvut.contains(Integer.valueOf(3))) {
luvut.remove(Integer.valueOf(3));
}

System.out.println("luvut poiston jälkeen:");

for (int luku : luvut) {
System.out.println(luku);
}
}
</pre>
  <p>Vaikka sisentämätön koodi toimii, on sitä hyvin ikävä lukea. Sisennetään koodi oikein (NetBeansissa sisennyksen saa korjattua automaattisesti painamalla alt+shift+f), ja erotellaan loogiset kokonaisuudet rivinvaihdoin:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
    luvut.add(4);
    luvut.add(3);
    luvut.add(7);
    luvut.add(3);

    System.out.println("luvut alussa:");

    // tässä tulostetaan luvut
    for (int luku : luvut) {
        System.out.println(luku);
    }

    // tarkastetaan onko listalla luku 3
    while (luvut.contains(Integer.valueOf(3))) {
        luvut.remove(Integer.valueOf(3));  // jos löytyi, niin poistetaan se
    }
    // tehdään tämä whilessä jotta saadaan kaikki kolmoset poistetua!

    System.out.println("luvut poiston jälkeen:");

    // tässä tulostetaan luvut
    for (int luku : luvut) {
        System.out.println(luku);
    }
}
</pre>
  <p>Nyt koodissa alkaa olla jo järkeä. Esimerkiksi tulostus ja kolmosten poisto ovat omia loogisia kokonaisuuksia, joten ne on erotettu rivinvaihdolla. Koodissa on <em>ilmavuutta</em> ja koodin lukeminen alkaa olla miellyttävämpää.</p>
  <p>Koodiin on vieläpä kirjoitettu kommentteja selventämään muutaman kohdan toimintaa.</p>
  <h3>Copy-pasten eliminointi metodeilla</h3>
  <p>Ohjelmoijan lähes pahin mahdollinen perisynti on copy-paste -koodi, eli samanlaisen koodinpätkän toistaminen koodissa useaan kertaan. Esimerkissämme listan tulostus tapahtuu kahteen kertaan. Tulostuksen hoitava koodi on syytä erottaa omaksi metodikseen ja kutsua uutta metodia pääohjelmasta:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
    luvut.add(4);
    luvut.add(3);
    luvut.add(7);
    luvut.add(3);

    System.out.println("luvut alussa:");

    // tässä tulostetaan luvut
    tulosta(luvut);

    while (luvut.contains(Integer.valueOf(3))) {
      luvut.remove(Integer.valueOf(3));
    }

    System.out.println("luvut poiston jälkeen:");

    // tässä tulostetaan luvut
    tulosta(luvut);
}

public static void tulosta(ArrayList&lt;Integer&gt; luvut) {
    for (int luku : luvut) {
        System.out.println( luku );
    }
}
</pre>
  <h3>Erillisten tehtävien erottaminen omiksi, selkeästi nimetyiksi metodeiksi</h3>
  <p>Koodi alkaa olla jo selkeämpää. Selvästi erillinen kokonaisuus, eli listan tulostus on oma helposti ymmärrettävä metodinsa. Uuden metodin esittelyn myötä myös pääohjelman luettavuus on kasvanut. Huomaa että uusi metodi on nimetty mahdollisimman kuvaavasti, eli siten että metodin nimi kertoo mitä metodi tekee. Ohjelmaan kirjoitetut kommentit <em>tässä tulostetaan luvut</em> ovatkin tarpeettomia, joten poistetaan ne.</p>
  <p>Ohjelmassa on vielä hiukan siistimisen varaa. Pääohjelma on vielä sikäli ikävä, että siistien metodikutsujen seassa on vielä suoraan listaa käsittelevä "epäesteettinen" koodinpätkä. Erotetaan tämäkin omaksi metodikseen:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
    luvut.add(4);
    luvut.add(3);
    luvut.add(7);
    luvut.add(3);

    System.out.println("luvut alussa:");
    tulosta(luvut);

    poista(luvut, 3);

    System.out.println("luvut poiston jälkeen:");
    tulosta(luvut);
}

public static void tulosta(ArrayList&lt;Integer&gt; luvut) {
    for (int luku : luvut) {
        System.out.println( luku );
    }
}

public static void poista(ArrayList&lt;Integer&gt; luvut, int poistettava) {
    while (luvut.contains(Integer.valueOf(poistettava))) {
        luvut.remove(Integer.valueOf(poistettava));
    }
}
</pre>
  <p>Loimme yllä loogiselle kokonaisuudelle -- tietyn luvun kaikkien esiintymien poistolle -- oman kuvaavasti nimetyn metodin. Lopputuloksena oleva pääohjelma on nyt erittäin ymmärrettävä, lähes suomen kieltä. Molemmat metodit ovat myös erittäin yksinkertaisia ja selkeitä ymmärtää.</p>
  <p>Kent Beck olisi varmaan tyytyväinen aikaansaannokseemme, koodi on helposti ymmärrettävää, helposti muokattavaa eikä sisällä copy-pastea.</p>
</div>
</section>